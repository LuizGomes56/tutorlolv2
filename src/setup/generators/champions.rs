use super::*;
use crate::{
    essentials::helpers::{extract_file_name, read_json_file, write_to_file},
    generators,
    model::{
        champions::{Ability, Champion},
        dev::champions::{CdnAbility, CdnChampion, Modifiers},
    },
};
use rustc_hash::FxHashMap;
use std::{fs, io::Write, path::Path};

include!(concat!(env!("OUT_DIR"), "/generator_runner.rs"));

/// Automatically updates every champion in the game. New champions, or big updates to existing
/// champions will need to be rewritten over time. If an error occurs while trying to update a
/// champion, it will be skipped. Writes the resulting json to internal/{champion_name}.json
pub fn run_generator_file(path_name: &str) -> Result<(), Box<dyn std::error::Error>> {
    let result: CdnChampion = read_json_file(path_name)?;
    let name = extract_file_name(Path::new(path_name));
    let name_lower = name.to_lowercase();
    let champion = try_run_generator(&name_lower, result);
    if let Some(champion_data) = champion {
        let string_value = serde_json::to_string_pretty(&champion_data)?;
        write_to_file(
            &format!("internal/champions/{}.json", name),
            string_value.as_bytes(),
        )?;
    } else {
        println!("Champion '{}' not found in transformation map", name);
    }
    Ok(())
}

/// Total = Replace all generator files
/// Partial = Replace non #[stable] and #[preserve] only
/// New = Only creates files for champions that were not listed
#[derive(Copy, Clone)]
pub enum GeneratorMode {
    Total,
    Partial,
    New,
}

/// Files will be generated automatically, but checked manually until it is
/// confirmed that the desired format was succesfully achieved.
/// Once it is done, a comment must be added to the header to
/// prevent the generator from editing that file with `#![stable]`, `#![preserve]`.
#[generator_macros::trace_time]
pub async fn create_generator_files(mode: GeneratorMode) -> Result<(), Box<dyn std::error::Error>> {
    let champion_names: FxHashMap<String, String> = read_json_file("internal/champion_names.json")?;
    let generator_target = "src/generators";

    let mut futures = Vec::new();
    let bind_function = |ability_name: &str, coords: Vec<String>| {
        "\tability!(\n\t\t$1,\n\t\t$2\n\t);\n"
            .replace("$1", ability_name)
            .replace("$2", &coords.join(",\n\t\t"))
    };

    for (_, champion_id) in champion_names {
        match mode {
            GeneratorMode::New => {
                if Path::new(&format!("src/generators/{}.rs", champion_id)).exists() {
                    continue;
                }
            }
            _ => {}
        };

        futures.push(tokio::spawn(async move {
            let path_name = format!("{}/{}.rs", generator_target, champion_id.to_lowercase());
            if let Ok(data) = std::fs::read_to_string(&path_name) {
                match mode {
                    GeneratorMode::Partial => {
                        if data.contains("#![stable]") || data.contains("#![preserve]") {
                            return;
                        }
                    }
                    _ => {}
                }
            }

            let mut autogenerated_content = format!(
                r#"use super::*;

// #![auto_generated]

#[generator_macros::generator]
pub fn gen_{}(data: CdnChampion) -> Champion {{
"#,
                champion_id.to_lowercase(),
            );

            let champion_data = match read_json_file::<CdnChampion>(&format!(
                "cache/cdn/champions/{}.json",
                champion_id
            )) {
                Ok(data) => data,
                Err(e) => {
                    eprintln!("Error reading champion file for {}: {:#?}", champion_id, e);
                    return;
                }
            };

            for (key, val) in champion_data.abilities.into_iterator() {
                let coords = transform_ability(&key.to_uppercase(), val);
                if coords.len() > 0 {
                    autogenerated_content.push_str(&bind_function(&key, coords));
                }
            }

            autogenerated_content.push_str("}");

            let _ = write_to_file(&path_name, autogenerated_content.trim().as_bytes());
        }));
    }

    for future in futures {
        if let Err(e) = future.await {
            eprintln!("Task join error: {}", e);
        }
    }

    Ok(())
}

/// Takes the reference of the description of one ability, the reference vector
/// where data will be written at, and adds the tuples of scalling found.
fn assign_scalings(description: &String, ref_vec: &mut Vec<String>) {
    if description.is_empty() {
        return;
    }
    let scalings: String = extract_scaled_values(&description);
    if scalings.len() > 0 {
        ref_vec.iter_mut().for_each(|dmg: &mut String| {
            *dmg = format!("{} + {}", dmg, scalings);
        });
    }
}

/// Easier way to get passive damage when the standard format (struct CdnChampion) matches.
///
/// `data` > the reference to the data passed to the caller function.
///
/// `indexes` > the (ability_index, effect_index) of the description string to be extracted.
///
/// `postfix` > optional hardcoded string to be added after each matching in final Vec<String>
///
/// `scalings` > optional index where the description string can be found to get passive's scallings
///
/// `target_vec` > determines if final ocurrence will be written in Minimum or Maximum vector
///
/// `keyname` > name of the key to be added in the map after final Vec<String> is created
///
/// `map` > reference to the map created internally by the caller function. (Must be created)
pub fn extract_passive_damage(
    data: &CdnChampion,
    indexes: (usize, usize),
    postfix: Option<&str>,
    scalings: Option<usize>,
    target_vec: &Target,
    keyname: &str,
    map: &mut FxHashMap<String, Ability>,
) {
    let mut minimum_damage: Vec<String> = Vec::<String>::new();
    let mut maximum_damage: Vec<String> = Vec::<String>::new();

    let (passive, passive_bounds) = extract_passive_bounds(&data, indexes);

    let mut description: &String = &String::new();

    if let Some(scalings) = scalings {
        description = &passive.effects[scalings].description;
    }

    match target_vec {
        Target::MINIMUM => {
            minimum_damage = process_linear_range(passive_bounds, 18, postfix);
            assign_scalings(&description, &mut minimum_damage);
        }
        Target::MAXIMUM => {
            maximum_damage = process_linear_range(passive_bounds, 18, postfix);
            assign_scalings(&description, &mut maximum_damage);
        }
    };

    map.insert(
        String::from(keyname),
        passive.format(minimum_damage, maximum_damage),
    );
}

/// Helper function to remove the decimal point if it's not needed, or expand floats.
fn trim_f64(val: f64) -> String {
    if val.fract() == 0.0 {
        format!("{:.0}", val)
    } else {
        format!("{}", val)
    }
}

/// Takes the default format of the API and assigns to target_vec the correct format
/// Used internally.
fn extract_ability(modifiers: &[Modifiers], target_vec: &mut Vec<String>) {
    if modifiers.is_empty() {
        return;
    }
    let length: usize = modifiers[0].values.len();
    for i in 0..length {
        let mut parts: Vec<String> = Vec::new();
        for modifier in modifiers {
            if let Some(value) = modifier.values.get(i) {
                let raw_unit: &str = modifier.units[i].trim();
                let scallings: String = extract_scaled_values(&raw_unit);
                let unit: String = remove_parenthesized_additions(&raw_unit);
                let cleaned_string: String = if unit.contains('%') {
                    let parts: Vec<&str> = unit.split('%').collect();
                    let suffix: String = parts
                        .get(1)
                        .map_or("".to_string(), |s: &&str| s.trim().to_string());
                    let coef: f64 = value / 100.0;
                    if coef == 1.0 && !suffix.is_empty() {
                        suffix
                    } else if !suffix.is_empty() {
                        format!("({} * {})", trim_f64(coef), suffix)
                    } else {
                        format!("{}", trim_f64(coef))
                    }
                } else if unit.is_empty() {
                    trim_f64(*value)
                } else {
                    format!("{}{}", trim_f64(*value), unit)
                };
                let formatted_string: String = replace_keys(&cleaned_string);
                let final_string: String = if scallings.is_empty() {
                    formatted_string
                } else {
                    format!("{} + {}", formatted_string, scallings)
                };
                parts.push(final_string);
            }
        }
        target_vec.push(parts.join(" + "));
    }
}

/// Lots of passive strings match with a pattern of (number) : (number) ... (+ Scalings)
/// This function returns the first two values it found, assuming there will always be two.
fn extract_passive_bounds(
    data: &CdnChampion,
    indexes: (usize, usize),
) -> (&CdnAbility, (f64, f64)) {
    let (ability_index, effect_index) = indexes;

    let passive: &CdnAbility = data
        .abilities
        .p
        .get(ability_index)
        .expect("ability_index is invalid.");

    let passive_effects: String = passive
        .effects
        .get(effect_index)
        .expect("effect_index is invalid.")
        .description
        .clone();

    let passive_bounds: (f64, f64) = extract_range_values(&passive_effects)
        .expect("Couldn't extract numeric values for passive.");

    (passive, passive_bounds)
}

/// Useful for passives where scalling is linear over all 18 levels.
/// Returns the array with the values for each level adjusted
fn process_linear_range(bounds: (f64, f64), size: usize, postfix: Option<&str>) -> Vec<String> {
    let mut result: Vec<String> = Vec::<String>::new();
    let (start, end) = bounds;
    for i in 0..size {
        let value: f64 = start + (((end - start) * (i as f64)) / (size as f64 - 1.0));
        if let Some(postfix) = postfix {
            result.push(format!("({} + {})", value, postfix));
            continue;
        }
        result.push(format!("{}", value));
    }
    result
}

/// Determines if it should be written in "minimum_damage" or "maximum_damage" field
/// "maximum_damage" may not be filled if no "minimum_damage" exists.
/// Doing so will cause the display to show "0 - {max_damage}"
/// While "minimum_damage" without "maximum_damage" will show "{min_damage}"
pub enum Target {
    MINIMUM,
    MAXIMUM,
}

type IteratorExtractor<'a> = FxHashMap<usize, FxHashMap<usize, (String, &'a Target)>>;

/// Takes a pattern of `[Index on Vec<Effect>], [Index on Vec<Leveling>], [(Keyname, Max/Min)]`
/// And assigns to the map the correct format that will be used internally.
pub fn extract_ability_damage(
    data: &CdnAbility,
    map: &mut FxHashMap<String, Ability>,
    pattern: &[(usize, usize, &str, Target)],
) {
    let mut indexes: IteratorExtractor = FxHashMap::default();

    for (effect_index, leveling_index, keyname, target_vector) in pattern.into_iter() {
        indexes
            .entry(*effect_index)
            .or_insert(FxHashMap::default())
            .insert(*leveling_index, (keyname.to_string(), target_vector));
    }

    for (effect_index, leveling) in indexes {
        for (leveling_index, (keyname, target_vector)) in leveling {
            let mut minimum_damage: Vec<String> = Vec::<String>::new();
            let mut maximum_damage: Vec<String> = Vec::<String>::new();

            if let Some(effects) = data.effects.get(effect_index) {
                if let Some(level_entry) = effects.leveling.get(leveling_index) {
                    let modifiers: &Vec<Modifiers> = &level_entry.modifiers;

                    match target_vector {
                        Target::MINIMUM => extract_ability(modifiers, &mut minimum_damage),
                        Target::MAXIMUM => extract_ability(modifiers, &mut maximum_damage),
                    }

                    map.insert(keyname, data.format(minimum_damage, maximum_damage));
                }
            } else {
                println!(
                    "Invalid index: effect: '{}' or leveling: '{}'",
                    effect_index, leveling_index
                );
                continue;
            }
        }
    }
}

/// Returns a new array with the coordinates where an ability was found according to CDN API
fn transform_ability(key: &str, abilities: &[CdnAbility]) -> Vec<String> {
    let mut generator_keybinds = Vec::<String>::new();

    for (ability_index, ability) in abilities.iter().enumerate() {
        for (effect_index, effect) in ability.effects.iter().enumerate() {
            for (leveling_index, leveling) in effect.leveling.iter().enumerate() {
                let attr = leveling
                    .attribute
                    .as_deref()
                    .unwrap_or_default()
                    .to_lowercase();

                if !attr.contains("damage") {
                    continue;
                }

                let suffix = if attr.contains("monster") {
                    "_MONSTER"
                } else if attr.contains("bonus") {
                    "_BONUS"
                } else if attr.contains("maximum")
                    || attr.contains("total")
                    || attr.contains("increased")
                {
                    "_MAXIMUM"
                } else if attr.contains("minimum") {
                    "_MINIMUM"
                } else {
                    ""
                };

                let base_key = format!(
                    "{}_{}_{}_{}",
                    key, ability_index, effect_index, leveling_index
                );
                let final_key = format!("{}{}", base_key, suffix);

                generator_keybinds.push(format!(
                    "({}, {}, \"{}\", {})",
                    effect_index,
                    leveling_index,
                    final_key,
                    if suffix.contains("MAX") {
                        "Target::MAXIMUM"
                    } else {
                        "Target::MINIMUM"
                    }
                ));
            }
        }
    }
    generator_keybinds
}

/// Order of Vec<Effect> from CDN API varies and to get a more consistent
/// result after each update, keys will be ordered. This function must be
/// called before running a generator file or a creating these generators
/// to avoid inconsistencies. This method is not perfect, manual adjustments
/// may be required if a major change occurs.
pub fn order_cdn_champion_effects() -> std::io::Result<()> {
    let input_dir = Path::new("cache/cdn/champions");
    for entry in fs::read_dir(input_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.extension().map_or(false, |ext| ext == "json") {
            let content = fs::read_to_string(&path)?;

            let mut champion: CdnChampion = match serde_json::from_str(&content) {
                Ok(c) => c,
                Err(err) => {
                    eprintln!("Erro ao desserializar {:?}: {}", path, err);
                    continue;
                }
            };

            for ability_list in [
                &mut champion.abilities.q,
                &mut champion.abilities.w,
                &mut champion.abilities.e,
                &mut champion.abilities.r,
                &mut champion.abilities.p,
            ] {
                for ability in ability_list {
                    ability
                        .effects
                        .sort_by(|a, b| a.description.cmp(&b.description));
                    for effect in &mut ability.effects {
                        effect.leveling.sort_by(|a, b| {
                            a.attribute
                                .as_deref()
                                .unwrap_or("")
                                .cmp(b.attribute.as_deref().unwrap_or(""))
                        });
                    }
                }
            }
            let mut output_file = fs::File::create(&path)?;
            output_file.write_all(serde_json::to_string_pretty(&champion).unwrap().as_bytes())?;
        }
    }
    Ok(())
}
