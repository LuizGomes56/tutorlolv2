use crate::model::{
    application::GlobalCache,
    champions::{CdnAbility, CdnChampion, Champion},
    internal::{MetaItems, Positions},
    items::{CdnItem, Effect, Item, ItemStats, PartialStats},
    realtime::DamageObject,
    runes::Rune,
    riot::{RiotCdnItem, RiotCdnStandard},
};
use regex::Regex;
use reqwest::{Client, Response};
use scraper::{Html, Selector};
use serde::de::DeserializeOwned;
use serde_json::{Map, Value};
use std::{
    borrow::Cow, collections::HashMap, env, fs::{self, DirEntry, ReadDir}, io::Write, path::{Path, PathBuf}, sync::Arc
};
use tokio::{sync::{Semaphore, SemaphorePermit}, task::{self, JoinHandle}};

use super::helpers::extract_damagelike_expr;
use super::*;

type MetaItemValue<T> = HashMap<String, HashMap<String, Vec<T>>>;

// Files will be generated automatically, but checked manually until it is confirmed that the desired
// format was succesfully achieved. Once it is done, a comment must be added to the header to
// prevent the generator from editing that file. "#![stable]".
pub async fn generate_writer_files() {
    let champion_names: HashMap<String, String> =
        read_from_file::<HashMap<String, String>>("internal/champion_names.json");

    let mut futures: Vec<JoinHandle<()>> = Vec::new();

    let bind_function = |ability_name: &str, coords: Vec<String>| {
        "\textract_ability_damage(\n\t\t&data.abilities.$1[0],\n\t\t&mut abilities,\n\t\t&[\n\t\t\t$2\n\t\t]\n\t);\n\n"
            .replace("$1", ability_name)
            .replace("$2", &coords.join(",\n\t\t\t"))
    };

    for (_, champion_id) in champion_names {
        futures.push(tokio::spawn(async move {
            let path_name: String = format!("src/writers/{}.rs", champion_id.to_lowercase());
            if let Ok(data) = fs::read_to_string(&path_name) {
                if data.contains("#![stable]") {
                    return;
                }
            }

            let mut autogenerated_content: String = String::from("use super::{\n\tAbility, CdnChampion, Champion,\n\tHashMap, Target, extract_ability_damage\n};\n\npub fn transform(data: CdnChampion) -> Champion {\n\tlet mut abilities = HashMap::<String, Ability>::new();\n\n");

            let champion_data: CdnChampion =
                read_from_file::<CdnChampion>(&format!("cache/cdn/champions/{}.json", champion_id));

            for (key, val) in champion_data.abilities.into_iterator() {
                let coords: Vec<String> = transform_ability(&key.to_uppercase(), val);
                if coords.len() > 0 {
                    autogenerated_content.push_str(&bind_function(&key, coords)); 
                }
            }

            autogenerated_content.push_str("\tdata.format(abilities)\n}");

            write_to_file(&path_name, autogenerated_content.trim().as_bytes());
        }));
    }

    for future in futures {
        _ = future.await;
    }
}

#[derive(Debug)]
pub enum CacheError {
    IoError(std::io::Error),
    SerdeError(serde_json::Error),
    PathBufError(std::path::PathBuf),
    ParseIntError(std::num::ParseIntError),
}

// Syncronously loads all the cache that will live in memory through the entire execution
pub fn load_cache() -> Result<GlobalCache, CacheError> {
    println!("fn[load_cache]: started loading champion_files");
    let mut champions: HashMap<String, Champion> = HashMap::new();
    match fs::read_dir("internal/champions") {
        Ok(read_dir) => {
            for entry in read_dir {
                let path_buf: PathBuf = entry.map_err(CacheError::IoError)?.path();
                let path_name: &str = path_buf
                    .to_str()
                    .ok_or_else(|| CacheError::PathBufError(path_buf.clone()))?;
                let file_name: &str = extract_file_name(&path_buf);
                let data: Champion = read_from_file::<Champion>(path_name);
                champions.insert(String::from(file_name), data);
            }
        }
        Err(e) => return Err(CacheError::IoError(e)),
    }

    println!("fn[load_cache]: started loading item_files");
    let mut items: HashMap<usize, Item> = HashMap::new();
    match fs::read_dir("internal/items") {
        Ok(read_dir) => {
            for entry in read_dir {
                let path_buf: PathBuf = entry.map_err(CacheError::IoError)?.path();
                let path_name: &str = path_buf
                    .to_str()
                    .ok_or_else(|| CacheError::PathBufError(path_buf.clone()))?;
                let file_name: &str = extract_file_name(&path_buf);
                let data: Item = read_from_file::<Item>(path_name);
                let item_id: usize = file_name.parse::<usize>().map_err(CacheError::ParseIntError)?;
                items.insert(item_id, data);        
            }
        }
        Err(e) => return Err(CacheError::IoError(e)),
    }

    let champion_names_path: &'static str = "internal/champion_names.json";
    let champion_names: HashMap<String, String>= if Path::new(champion_names_path).exists() {
        println!("fn[load_cache]: started loading champion_names");    
        read_from_file::<HashMap<String, String>>("internal/champion_names.json")
    } else {
        HashMap::new()
    };
    
    let meta_items_path: &'static str = "internal/meta_items.json";
    let meta_items: HashMap<String, Positions> = if Path::new(meta_items_path).exists() {
        println!("fn[load_cache]: started loading meta_items");
        read_from_file::<MetaItems>("internal/meta_items.json")
    } else {
        HashMap::new()
    };
    
    let runes_path: &'static str = "internal/runes.json";
    let runes: HashMap<usize, Rune> = if Path::new(runes_path).exists() {
        println!("fn[load_cache]: started loading runes");
        read_from_file::<HashMap<usize, Rune>>("internal/runes.json")
    } else {
        HashMap::new()
    };
    
    Ok(GlobalCache {
        champions,
        items,
        runes,
        champion_names,
        meta_items,
    })
}

// Helper function to fetch data from the CDN. Returns a HashMap with `any` value.
async fn fetch_cdn_api(client: Client ,path_name: &str) -> HashMap<String, Value> {
    let uri: String = env::var("CDN_ENDPOINT").expect("CDN_ENDPOINT is not set");
    let url: &String = &format!("{}/{}", uri.trim_end_matches('/'), path_name);

    println!("fetch_cdn_api: {}", url);

    let res = client
        .get(url)
        .send()
        .await
        .expect("Failed to send request");

    let data: Value = res.json().await.expect("Failed to parse JSON");

    let result: &Map<String, Value> = data.as_object().expect("Failed to convert JSON to object");
    result.clone().into_iter().collect()
}

// Fetches DataDragon API from Riot Games. Only the final file path needs to be provided
async fn fetch_riot_api<T: DeserializeOwned>(client: Client, path_name: &str) -> T {
    let uri: String = env::var("DD_DRAGON_ENDPOINT").expect("DD_DRAGON_ENDPOINT is not set");
    let version: String = env::var("LOL_VERSION").expect("LOL_VERSION is not set");
    let language: String = env::var("LOL_LANGUAGE").expect("LOL_LANGUAGE is not set");
    let url: &String = &format!(
            "{}/{}/data/{}/{}.json",
            uri.trim_end_matches('/'),
            version,
            language,
            path_name
        );  

    println!("fetch_riot_api: {}", url);

    let res: Response = client
        .get(url)
        .send()
        .await
        .expect("Failed to send request");

    let data: T = res.json::<T>().await.expect("Failed to parse JSON");
    data
}

// Updates files in `cache/riot` with the corresponding ones in the patch determined by `LOL_VERSION`
// Runs a maximum of 32 tokio threads at the same time
pub async fn update_riot_cache(client: Client) {
    let champions_json: RiotCdnStandard = fetch_riot_api::<RiotCdnStandard>(client.clone(), "champion").await;
    let mut champions_futures: Vec<JoinHandle<()>> = Vec::new();
    let champions_semaphore: Arc<Semaphore> = Arc::new(Semaphore::new(1 << 5));

    for (champion_id, _) in champions_json.data.clone() {
        let client: Client = client.clone();
        let semaphore: Arc<Semaphore> = champions_semaphore.clone();

        champions_futures.push(tokio::spawn(async move {
            let _permit: SemaphorePermit<'_> = semaphore.acquire().await.unwrap();

            let this_path_name: String = format!("cache/riot/champions/{}.json", champion_id);
            let this_champion_data: RiotCdnStandard =
                fetch_riot_api::<RiotCdnStandard>(client, &format!("champion/{}", champion_id)).await;
            let data_field: HashMap<String, Value> = this_champion_data.data;
            let real_data: Value = data_field.get(&champion_id.to_string()).unwrap().clone();
            let strval: String = serde_json::to_string(&real_data).unwrap();
            write_to_file(&this_path_name, strval.as_bytes());
        }));
    }

    for champion_future in champions_futures {
        let _ = champion_future.await;
    }

    let champion_strval: String = serde_json::to_string_pretty(&champions_json).unwrap();
    let champion_bytes: &[u8] = champion_strval.as_bytes();
    write_to_file("cache/riot/champions.json", champion_bytes);

    let items_json: RiotCdnStandard = fetch_riot_api::<RiotCdnStandard>(client.clone(), "item").await;
    let mut items_futures: Vec<JoinHandle<()>> = Vec::new();

    for (item_id, item_data) in items_json.data.clone() {
        items_futures.push(task::spawn_blocking(move || {
            let this_path_name: String = format!("cache/riot/items/{}.json", item_id);
            let strval: String = serde_json::to_string(&item_data).unwrap();
            write_to_file(&this_path_name, strval.as_bytes());
        }));
    }

    for item_future in items_futures {
        let _ = item_future.await;
    }

    let item_strval: String = serde_json::to_string_pretty(&items_json).unwrap();
    let item_bytes: &[u8] = item_strval.as_bytes();
    write_to_file("cache/riot/items.json", item_bytes);

    let runes_json: Value = fetch_riot_api::<Value>(client, "runesReforged").await;
    let runes_strval: String = serde_json::to_string_pretty(&runes_json).unwrap();
    let runes_bytes: &[u8] = runes_strval.as_bytes();
    write_to_file("cache/riot/runes.json", runes_bytes);
}

// Recovers all the common builds for the current patch so the app can recommend builds to the user
// Average time to update is 2m30s. Making the outer loop a new task overloads the target website
// causing requests to timeout.
pub async fn get_meta_items(client: Client) {
    let champion_names: HashMap<String, String> =
        read_from_file::<HashMap<String, String>>("internal/champion_names.json");

    let positions = ["top", "jungle", "mid", "adc", "support"];
    let mut collected_results = HashMap::<String, HashMap<String, Vec<String>>>::new();

    for (_, name) in champion_names {
        let mut second_future = Vec::new();
        for position in positions {
            let champion_name: String = name.to_lowercase().clone();
            let client: Client = client.clone();
            second_future.push(tokio::spawn(async move {
                let endpoint: String = env::var("META_ENDPOINT").expect("META_ENDPOINT is not set");
                let url: String = format!("{}/{}/build/{}", endpoint, champion_name, position);

                let res = client
                    .get(url)
                    .send()
                    .await
                    .expect("Failed to send request");

                let mut result = HashMap::<String, Vec<String>>::new();

                let html: String = res.text().await.expect("Could not read response text");
                let document: Html = Html::parse_document(&html);
                let full_build: Selector = Selector::parse(".m-1q4a7cx:nth-of-type(4) > div > div img")
                    .expect("Failed to parse nested selector");
                let situational_build: Selector = Selector::parse(".m-s76v8c > div > div img")
                    .expect("Failed to parse selector .m-s76v8c");

                let mut items: Vec<String> = Vec::<String>::new();
                let mut push_items = |selector: &Selector| {
                    for img in document.select(selector) {
                        if let Some(alt) = img.value().attr("alt") {
                            items.push(alt.to_string());
                        }
                    }
                };
                push_items(&full_build);
                push_items(&situational_build);
                result.insert(String::from(position), items);
                result
            }));
        }

        let mut collected_result: HashMap<String, Vec<String>> = HashMap::new();
        for result in second_future {
            println!("Fetching meta items for {}", name);
            collected_result.extend(result.await.unwrap());
        }
        collected_results.insert(name, collected_result);
    }

    write_to_file(
        "internal/meta_items.json",
        serde_json::to_string(&collected_results)
            .unwrap()
            .as_bytes(),
    );
}

// Takes an instance parameter and uses CDN API to get its data and save to file system.
pub async fn update_cdn_cache(client: Client, instance: &str) {
    let result: HashMap<String, Value> = fetch_cdn_api(client, &format!("{}.json", instance)).await;

    for (key, value) in result {
        let folder_name: String = format!("cache/cdn/{}", instance);
        task::spawn_blocking(move || {
            let path_name: String = format!("{}/{}.json", folder_name, key);
            let strval: String = value.to_string();
            write_to_file(&path_name, strval.as_bytes());
        });
    }
}

// Creates basic folders necessary to run the program. If one of these folders are not found,
// The program is likely to panic when an update is called.
pub fn setup_project_folders() {
    for dir in [
        "formulas",
        "img",
        "img/champions",
        "img/runes",
        "img/centered",
        "img/splash",
        "img/abilities",
        "img/items",
        "img/other",
        "img/stats",
        "cache",
        "cache/cdn",
        "cache/cdn/champions",
        "cache/cdn/items",
        "cache/riot",
        "cache/riot/champions",
        "cache/riot/items",
        "internal",
        "internal/items",
        "internal/champions",
    ] {
        let path: &Path = Path::new(dir);
        if !path.exists() {
            let error_msg: String = format!("Unable to create directory '{}'", dir);

            fs::create_dir_all(path).expect(&error_msg);
        }
    }
}

// Helper function to write files
pub fn write_to_file(path_name: &str, bytes: &[u8]) {
    println!("write_to_file: {}", path_name);

    let mut file = std::fs::File::create(path_name).expect("Unable to create file");
    file.write_all(bytes).expect("Unable to write data");
}

// Helper to read from files and parse the value to a struct
pub fn read_from_file<T: DeserializeOwned>(path_name: &str) -> T {
    println!("read_from_file: {}", path_name);
    
    let data: String = fs::read_to_string(path_name).expect(&format!("Unable to read file [fn read_from_file<T: DeserializeOwned>(path_name: &str) -> T]: {}", path_name));
    serde_json::from_str(&data).expect("Failed to parse JSON")
}

// Read every file in cache/cdn/champions folder and delegates the processing to generate_champion_file
pub fn setup_champion_cache() {
    let files: ReadDir = fs::read_dir("cache/cdn/champions")
        .expect("Unable to read directory cache/cdn/champions");

    for file in files {
        let path_name: PathBuf = file.unwrap().path();
        task::spawn_blocking(move || {
            let strpath: &str = path_name.to_str().expect("Failed to convert path to string at [setup_champion_cache]");
            println!("fn[setup_champion_cache]: {}", strpath);
            generate_champion_file(strpath);
        });
    }
}

// Not meant to be used frequently. Just a quick check for every
// patch to identify if a new damaging item was added
pub fn identify_damaging_items() {
    println!("fn[identify_damaging_items]");
    let contains_damage_outside_template = |text: &str| -> bool {
        let re: Regex = Regex::new(r"\{\{[^}]*\}\}").unwrap();
        let cleaned: Cow<'_, str> = re.replace_all(text, "");
        cleaned.contains("damage")
    };
    let files: ReadDir =
        fs::read_dir("cache/cdn/items").expect("Unable to read directory cache/cdn/items");
    let mut is_damaging: Vec<usize> = Vec::new();
    for file in files {
        let path_buf: PathBuf = file.unwrap().path();
        let path_name: &str = path_buf.to_str().unwrap();
        let result: CdnItem = read_from_file::<CdnItem>(path_name);
        if !result.shop.purchasable {
            continue;
        }
        let mut found_match: bool = false;
        if !result.passives.is_empty() {
            for passive in &result.passives {
                if contains_damage_outside_template(&passive.effects) {
                    found_match = true;
                }
            }
        }
        if !result.active.is_empty() {
            for active in &result.active {
                if contains_damage_outside_template(&active.effects) {
                    found_match = true;
                }
            }
        }
        if found_match {
            is_damaging.push(result.id);
        }
    }
    is_damaging.sort();
    write_to_file(
        "internal/damaging_items.json",
        serde_json::to_string_pretty(&is_damaging)
            .unwrap()
            .as_bytes(),
    );
}

// Replaces the content found in the files to a shorter and adapted version,
// initializes items as default, and Damaging stats must be added separately.
pub fn initialize_items() {
    println!("fn[initialize_items]");
    let non_zero = |val: f64| -> Option<f64> { if val == 0.0 { None } else { Some(val) } };

    let files: ReadDir =
        fs::read_dir("cache/cdn/items").expect("Unable to read directory cache/cdn/items");
    for file in files {
        task::spawn_blocking(move || {
            let path_buf: PathBuf = file.unwrap().path();
            let path_name: &str = path_buf.to_str().unwrap();

            println!("fn[initialize_items]: [initializing] {}", path_name);

            let cdn_item: CdnItem = read_from_file::<CdnItem>(path_name);

            let stats: &ItemStats = &cdn_item.stats;
            let mut item_stats: PartialStats = PartialStats::default();

            item_stats.ability_power = non_zero(stats.ability_power.flat);
            item_stats.armor = non_zero(stats.armor.flat);
            item_stats.attack_damage = non_zero(stats.attack_damage.flat);
            item_stats.attack_speed = non_zero(stats.attack_speed.flat);
            item_stats.critical_strike_chance = non_zero(stats.critical_strike_chance.flat);
            item_stats.critical_strike_damage = non_zero(stats.critical_strike_damage.flat);
            item_stats.health = non_zero(stats.health.flat);
            item_stats.lifesteal = non_zero(stats.lifesteal.flat);
            item_stats.magic_resistance = non_zero(stats.magic_resistance.flat);
            item_stats.mana = non_zero(stats.mana.flat);
            item_stats.movespeed = non_zero(stats.movespeed.flat);
            item_stats.omnivamp = non_zero(stats.omnivamp.flat);

            item_stats.armor_penetration_flat = non_zero(stats.armor_penetration.flat);
            item_stats.armor_penetration_percent = non_zero(stats.armor_penetration.percent);

            item_stats.magic_penetration_flat = non_zero(stats.magic_penetration.flat);
            item_stats.magic_penetration_percent = non_zero(stats.magic_penetration.percent);

            let get_damagelike_expr_from_vec = |source_vec: Vec<Effect>| -> Option<String> {
                source_vec
                    .get(0)
                    .map(|p: &Effect| extract_damagelike_expr(&p.effects))
                    .filter(|s: &String| !s.is_empty())
            };

            let damage_str: Option<String> = get_damagelike_expr_from_vec(cdn_item.passives)
                .or_else(|| get_damagelike_expr_from_vec(cdn_item.active));

            let (melee, ranged) = damage_str
                .as_ref()
                .filter(|s: &&String| s.chars().any(|c: char| c.is_ascii_digit()))
                .map(|s: &String| {
                    let item_dmg: DamageObject = DamageObject {
                        minimum_damage: Some(s.clone()),
                        maximum_damage: None,
                    };
                    (Some(item_dmg.clone()), Some(item_dmg))
                })
                .unwrap_or((None, None));

            let result: Item = Item {
                pretiffied_stats: HashMap::new(),
                name: cdn_item.name,
                gold: cdn_item.shop.prices.total,
                levelings: None,
                damage_type: None,
                damages_onhit: false,
                stats: item_stats,
                builds_from: cdn_item.builds_from,
                ranged,
                melee,
            };

            write_to_file(
                format!("internal/items/{}.json", cdn_item.id).as_str(),
                serde_json::to_string(&result).unwrap().as_bytes(),
            );
        });
    }
}

// Uses champion display name and converts to their respective ids, saving to internal
pub fn rewrite_champion_names() {
    println!("fn[rewrite_champion_names]");
    let files: ReadDir = fs::read_dir("cache/cdn/champions")
        .expect("Unable to read directory cache/cdn/champions");

    let mut map: HashMap<String, String> = HashMap::<String, String>::new();

    for file in files {
        let path_buf: PathBuf = file.unwrap().path();
        let path_name: &str = path_buf.to_str().unwrap();
        let result: CdnChampion = read_from_file::<CdnChampion>(path_name);
        let name: &str = extract_file_name(&path_buf);
        map.insert(result.name, name.to_string());
    }

    write_to_file(
        "internal/champion_names.json",
        serde_json::to_string(&map).unwrap().as_bytes(),
    );
}

// Automatically updates every champion in the game. New champions, or big updates to existing
// champions will need to be rewritten over time. If an error occurs while trying to update a
// champion, it will be skipped. Writes the resulting json to internal/{champion_name}.json
fn generate_champion_file(path_name: &str) {
    let result: CdnChampion = read_from_file::<CdnChampion>(path_name);
    let name: &str = extract_file_name(Path::new(path_name));

    let champion: Option<Champion> = match name {
        "Aatrox" => Some(aatrox::transform(result)),
        "Ahri" => Some(ahri::transform(result)),
        "Akali" => Some(akali::transform(result)),
        "Akshan" => Some(akshan::transform(result)),
        "Alistar" => Some(alistar::transform(result)),
        "Ambessa" => Some(ambessa::transform(result)),
        "Amumu" => Some(amumu::transform(result)),
        "Anivia" => Some(anivia::transform(result)),
        "Annie" => Some(annie::transform(result)),
        "Aphelios" => Some(aphelios::transform(result)),
        "Ashe" => Some(ashe::transform(result)),
        "AurelionSol" => Some(aurelionsol::transform(result)),
        "Aurora" => Some(aurora::transform(result)),
        "Azir" => Some(azir::transform(result)),
        "Bard" => Some(bard::transform(result)),
        "Belveth" => Some(belveth::transform(result)),
        "Blitzcrank" => Some(blitzcrank::transform(result)),
        "Brand" => Some(brand::transform(result)),
        "Braum" => Some(braum::transform(result)),
        "Briar" => Some(briar::transform(result)),
        "Caitlyn" => Some(caitlyn::transform(result)),
        "Camille" => Some(camille::transform(result)),
        "Cassiopeia" => Some(cassiopeia::transform(result)),
        "Chogath" => Some(chogath::transform(result)),
        "Corki" => Some(corki::transform(result)),
        "Darius" => Some(darius::transform(result)),
        "Diana" => Some(diana::transform(result)),
        "Draven" => Some(draven::transform(result)),
        "DrMundo" => Some(drmundo::transform(result)),
        "Ekko" => Some(ekko::transform(result)),
        "Elise" => Some(elise::transform(result)),
        "Evelynn" => Some(evelynn::transform(result)),
        "Ezreal" => Some(ezreal::transform(result)),
        "Fiddlesticks" => Some(fiddlesticks::transform(result)),
        "Fiora" => Some(fiora::transform(result)),
        "Fizz" => Some(fizz::transform(result)),
        "Galio" => Some(galio::transform(result)),
        "Gangplank" => Some(gangplank::transform(result)),
        "Garen" => Some(garen::transform(result)),
        "Gnar" => Some(gnar::transform(result)),
        "Gragas" => Some(gragas::transform(result)),
        "Graves" => Some(graves::transform(result)),
        "Gwen" => Some(gwen::transform(result)),
        "Hecarim" => Some(hecarim::transform(result)),
        "Heimerdinger" => Some(heimerdinger::transform(result)),
        "Hwei" => Some(hwei::transform(result)),
        "Illaoi" => Some(illaoi::transform(result)),
        "Irelia" => Some(irelia::transform(result)),
        "Ivern" => Some(ivern::transform(result)),
        "Janna" => Some(janna::transform(result)),
        "JarvanIV" => Some(jarvaniv::transform(result)),
        "Jax" => Some(jax::transform(result)),
        "Jayce" => Some(jayce::transform(result)),
        "Jhin" => Some(jhin::transform(result)),
        "Jinx" => Some(jinx::transform(result)),
        "Kaisa" => Some(kaisa::transform(result)),
        "Kalista" => Some(kalista::transform(result)),
        "Karma" => Some(karma::transform(result)),
        "Karthus" => Some(karthus::transform(result)),
        "Kassadin" => Some(kassadin::transform(result)),
        "Katarina" => Some(katarina::transform(result)),
        "Kayle" => Some(kayle::transform(result)),
        "Kayn" => Some(kayn::transform(result)),
        "Kennen" => Some(kennen::transform(result)),
        "Khazix" => Some(khazix::transform(result)),
        "Kindred" => Some(kindred::transform(result)),
        "Kled" => Some(kled::transform(result)),
        "KogMaw" => Some(kogmaw::transform(result)),
        "KSante" => Some(ksante::transform(result)),
        "Leblanc" => Some(leblanc::transform(result)),
        "LeeSin" => Some(leesin::transform(result)),
        "Leona" => Some(leona::transform(result)),
        "Lillia" => Some(lillia::transform(result)),
        "Lissandra" => Some(lissandra::transform(result)),
        "Lucian" => Some(lucian::transform(result)),
        "Lulu" => Some(lulu::transform(result)),
        "Lux" => Some(lux::transform(result)),
        "Malphite" => Some(malphite::transform(result)),
        "Malzahar" => Some(malzahar::transform(result)),
        "Maokai" => Some(maokai::transform(result)),
        "MasterYi" => Some(masteryi::transform(result)),
        "Mel" => Some(mel::transform(result)),
        "Milio" => Some(milio::transform(result)),
        "MissFortune" => Some(missfortune::transform(result)),
        "MonkeyKing" => Some(monkeyking::transform(result)),
        "Mordekaiser" => Some(mordekaiser::transform(result)),
        "Morgana" => Some(morgana::transform(result)),
        "Naafiri" => Some(naafiri::transform(result)),
        "Nami" => Some(nami::transform(result)),
        "Nasus" => Some(nasus::transform(result)),
        "Nautilus" => Some(nautilus::transform(result)),
        "Neeko" => Some(neeko::transform(result)),
        "Nidalee" => Some(nidalee::transform(result)),
        "Nilah" => Some(nilah::transform(result)),
        "Nocturne" => Some(nocturne::transform(result)),
        "Nunu" => Some(nunu::transform(result)),
        "Olaf" => Some(olaf::transform(result)),
        "Orianna" => Some(orianna::transform(result)),
        "Ornn" => Some(ornn::transform(result)),
        "Pantheon" => Some(pantheon::transform(result)),
        "Poppy" => Some(poppy::transform(result)),
        "Pyke" => Some(pyke::transform(result)),
        "Qiyana" => Some(qiyana::transform(result)),
        "Quinn" => Some(quinn::transform(result)),
        "Rakan" => Some(rakan::transform(result)),
        "Rammus" => Some(rammus::transform(result)),
        "RekSai" => Some(reksai::transform(result)),
        "Rell" => Some(rell::transform(result)),
        "Renata" => Some(renata::transform(result)),
        "Renekton" => Some(renekton::transform(result)),
        "Rengar" => Some(rengar::transform(result)),
        "Riven" => Some(riven::transform(result)),
        "Rumble" => Some(rumble::transform(result)),
        "Ryze" => Some(ryze::transform(result)),
        "Samira" => Some(samira::transform(result)),
        "Sejuani" => Some(sejuani::transform(result)),
        "Senna" => Some(senna::transform(result)),
        "Seraphine" => Some(seraphine::transform(result)),
        "Sett" => Some(sett::transform(result)),
        "Shaco" => Some(shaco::transform(result)),
        "Shen" => Some(shen::transform(result)),
        "Shyvana" => Some(shyvana::transform(result)),
        "Singed" => Some(singed::transform(result)),
        "Sion" => Some(sion::transform(result)),
        "Sivir" => Some(sivir::transform(result)),
        "Skarner" => Some(skarner::transform(result)),
        "Smolder" => Some(smolder::transform(result)),
        "Sona" => Some(sona::transform(result)),
        "Soraka" => Some(soraka::transform(result)),
        "Swain" => Some(swain::transform(result)),
        "Sylas" => Some(sylas::transform(result)),
        "Syndra" => Some(syndra::transform(result)),
        "TahmKench" => Some(tahmkench::transform(result)),
        "Taliyah" => Some(taliyah::transform(result)),
        "Talon" => Some(talon::transform(result)),
        "Taric" => Some(taric::transform(result)),
        "Teemo" => Some(teemo::transform(result)),
        "Thresh" => Some(thresh::transform(result)),
        "Tristana" => Some(tristana::transform(result)),
        "Trundle" => Some(trundle::transform(result)),
        "Tryndamere" => Some(tryndamere::transform(result)),
        "TwistedFate" => Some(twistedfate::transform(result)),
        "Twitch" => Some(twitch::transform(result)),
        "Udyr" => Some(udyr::transform(result)),
        "Urgot" => Some(urgot::transform(result)),
        "Varus" => Some(varus::transform(result)),
        "Vayne" => Some(vayne::transform(result)),
        "Veigar" => Some(veigar::transform(result)),
        "Velkoz" => Some(velkoz::transform(result)),
        "Vex" => Some(vex::transform(result)),
        "Vi" => Some(vi::transform(result)),
        "Viego" => Some(viego::transform(result)),
        "Viktor" => Some(viktor::transform(result)),
        "Vladimir" => Some(vladimir::transform(result)),
        "Volibear" => Some(volibear::transform(result)),
        "Warwick" => Some(warwick::transform(result)),
        "Xayah" => Some(xayah::transform(result)),
        "Xerath" => Some(xerath::transform(result)),
        "XinZhao" => Some(xinzhao::transform(result)),
        "Yasuo" => Some(yasuo::transform(result)),
        "Yone" => Some(yone::transform(result)),
        "Yorick" => Some(yorick::transform(result)),
        "Yuumi" => Some(yuumi::transform(result)),
        "Zac" => Some(zac::transform(result)),
        "Zed" => Some(zed::transform(result)),
        "Zeri" => Some(zeri::transform(result)),
        "Ziggs" => Some(ziggs::transform(result)),
        "Zilean" => Some(zilean::transform(result)),
        "Zoe" => Some(zoe::transform(result)),
        "Zyra" => Some(zyra::transform(result)),
        _ => None,
    };

    if !champion.is_none() {
        let string_value: String = serde_json::to_string_pretty(&champion).unwrap();

        write_to_file(
            &format!("internal/champions/{}.json", name),
            string_value.as_bytes(),
        );
    }
}

// `internal/items` folder must exist, as well as dir `cache/riot/items`. Takes every file
// and reads the "description" value from Riot `item.json` and parses its XML into a HashMap
// only updates the key `prettified_stats`. All the remaining content remains the same
pub async fn append_prettified_item_stats() {
    println!("fn[append_prettified_item_stats]");
    let files: ReadDir =
        fs::read_dir("cache/riot/items").expect("Unable to read directory cache/cdn/items");

    let mut item_futures = Vec::new();
    for file in files {
        item_futures.push(task::spawn_blocking(move || {
            let path_buf: PathBuf = file.unwrap().path();
            let name: &str = extract_file_name(&path_buf);
            let path_name: String = format!("cache/riot/items/{}.json", name);
            let pretiffied_stats: HashMap<String, Value> = pretiffy_item_stats(&path_name);
            let internal_path: String = format!("internal/items/{}.json", name);
            if !Path::new(&internal_path).exists() {
                println!("Item {} does not exist", name);
                return;
            }
            let mut current_content: Item = read_from_file::<Item>(internal_path.as_str());
            current_content.pretiffied_stats = pretiffied_stats;
            let strval: String = serde_json::to_string(&current_content).unwrap();
            write_to_file(&internal_path, strval.as_bytes());
        }));
    }
    for future in item_futures {
        let _ = future.await;
    }
}

// When MetaItems are recovered, each item is written in the array with its name instead of ID
// This function replaces those names with IDs without changing the rest of the content.
// If one's ID is not found, it will remain unchanged
pub fn replace_item_names_with_ids() {
    println!("fn[replace_item_names_with_ids]");
    let mut meta_items: MetaItemValue<Value> = read_from_file::<MetaItemValue<Value>>("internal/meta_items.json");
    let items_folder: ReadDir = fs::read_dir("internal/items").expect("Failed to read items folder");

    // 4 `for` loops does not look pretty, but there's the only way to do it
    // 170 * 5 * 7 * 7 = 41650 expected iterations
    for entry in items_folder {
        let entry: DirEntry = entry.expect("Invalid DirEntry");
        let path: PathBuf = entry.path();
        let file_name: &str = extract_file_name(&path);
        let item_id: usize = file_name.parse::<usize>().unwrap_or(0);

        let internal_item: Item =
            read_from_file::<Item>(path.to_str().expect("Failed to convert path to string"));

        for (_, positions) in meta_items.iter_mut() {
            for (_, items) in positions.iter_mut() {
                for item in items.iter_mut() {
                    if let Value::String(s) = item {
                        if s == &internal_item.name {
                            *item = Value::Number(item_id.into());
                        }
                    }
                }
            }
        }
    }
    write_to_file(
        "internal/meta_items.json",
        serde_json::to_string_pretty(&meta_items)
            .unwrap()
            .as_bytes(),
    );
}

// Returns a new array with the coordinates where an ability was found according to CDN API
fn transform_ability(key: &str, abilities: &Vec<CdnAbility>) -> Vec<String> {
    let mut writer_keybinds: Vec<String> = Vec::<String>::new();

    for (ability_index, ability) in abilities.iter().enumerate() {
        for (effect_index, effect) in ability.effects.iter().enumerate() {
            for (leveling_index, leveling) in effect.leveling.iter().enumerate() {
                let attr: String = leveling
                    .attribute
                    .as_deref()
                    .unwrap_or_default()
                    .to_lowercase();

                if !attr.contains("damage") {
                    continue;
                }

                let suffix: &'static str = if attr.contains("monster") {
                    "_MONSTER"
                } else if attr.contains("bonus") {
                    "_BONUS"
                } else if attr.contains("maximum")
                    || attr.contains("total")
                    || attr.contains("increased")
                {
                    "_MAXIMUM"
                } else if attr.contains("minimum") {
                    "_MINIMUM"
                } else {
                    ""
                };

                let base_key: String = format!("{}_{}_{}_{}", key, ability_index, effect_index, leveling_index);
                let final_key: String = format!("{}{}", base_key, suffix);

                writer_keybinds.push(format!(
                    "({}, {}, \"{}\", {})",
                    effect_index,
                    leveling_index,
                    final_key,
                    if suffix.contains("MAX") {
                        "Target::MAXIMUM"
                    } else {
                        "Target::MINIMUM"
                    }
                ));
            }
        }
    }
    writer_keybinds
}

// Returns the value that will be added to key `pretiffied_stats` for each item.
// Depends on Riot API `item.json` and requires manual maintainance if a new XML tag is added
fn pretiffy_item_stats(path_name: &str) -> HashMap<String, Value> {
    let data: RiotCdnItem = read_from_file::<RiotCdnItem>(path_name);
    let mut result: HashMap<String, Value> = HashMap::new();

    // #![manual_impl]
    let tag_regex: Regex = Regex::new(r#"<(attention|buffedStat|nerfedStat|ornnBonus)>(.*?)<\/(attention|buffedStat|nerfedStat|ornnBonus)>"#).unwrap();
    let line_regex: Regex = Regex::new(r"(.*?)<br>").unwrap();
    let percent_prefix_regex: Regex = Regex::new(r"^\s*\d+\s*%?\s*").unwrap();
    let tag_strip_regex: Regex = Regex::new(r"<\/?[^>]+(>|$)").unwrap();

    let u: [&'static str; 4] = ["buffedStat", "nerfedStat", "attention", "ornnBonus"];
    let k: [&'static str; 2] = ["Cooldown", "Healing"];

    let lines: Vec<_> = line_regex.captures_iter(&data.description).collect();
    let mut line_index: usize = 0;

    for caps in tag_regex.captures_iter(&data.description) {
        let t: &str = &caps[1];
        let v: String = caps[2].replace('%', "");
        let mut n: Option<String> = None;
        if line_index < lines.len() {
            let cleaned: String = tag_strip_regex
                .replace_all(&lines[line_index][1], "")
                .trim()
                .to_string();
            if !cleaned.is_empty() {
                n = Some(cleaned);
            }
            line_index += 1;
        }
        if u.contains(&t) {
            if let Some(n_val) = &n {
                let j: String = percent_prefix_regex.replace(n_val, "").trim().to_string();
                if !j.is_empty() {
                    let is_percent: bool = caps[2].contains('%');
                    let value: Value =
                        if k.iter().any(|&keyword| n_val.contains(keyword)) && is_percent {
                            Value::String(format!("{}%", v))
                        } else {
                            match v.parse::<f64>() {
                                Ok(num) => Value::from(num),
                                Err(_) => continue,
                            }
                        };
                    result.insert(j, value);
                }
            }
        }
    }
    result
}
