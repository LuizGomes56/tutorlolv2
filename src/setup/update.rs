use crate::{
    model::{
        application::GlobalCache,
        champions::{CdnAbility, CdnChampion, Champion},
        internal::MetaItems,
        items::{CdnItem, Effect, Item, ItemStats, PartialStats},
        realtime::DamageObject,
        riot::{RiotCdnItem, RiotCdnStandard},
        runes::Rune,
    },
    setup::helpers::extract_file_name,
};
use regex::Regex;
use reqwest::{Client, Response};
use scraper::{Html, Selector};
use serde::de::DeserializeOwned;
use serde_json::{Map, Value};
use std::{
    borrow::Cow,
    collections::HashMap,
    env,
    fs::{self, DirEntry, ReadDir},
    hash::Hash,
    io::{self, Write},
    num::ParseIntError,
    path::{Path, PathBuf},
    sync::Arc,
};
use tokio::{
    sync::{Semaphore, SemaphorePermit},
    task::{self, JoinHandle},
};

use super::helpers::extract_damagelike_expr;
use crate::writers;

include!(concat!(env!("OUT_DIR"), "/writers_generated.rs"));

type MetaItemValue<T> = HashMap<String, HashMap<String, Vec<T>>>;

// Files will be generated automatically, but checked manually until it is
// confirmed that the desired format was succesfully achieved.
// Once it is done, a comment must be added to the header to
// prevent the generator from editing that file. "#![stable]".
pub async fn generate_writer_files() {
    let champion_names: HashMap<String, String> = read_from_file("internal/champion_names.json");
    let environment: String = env::var("ENVIRONMENT").expect("ENVIRONMENT is not set");
    let writer_target: &'static str = if environment == "PRODUCTION" {
        "formulas"
    } else {
        "src/writers"
    };

    let mut futures: Vec<JoinHandle<()>> = Vec::new();
    let bind_function = |ability_name: &str, coords: Vec<String>| {
        "\textract_ability_damage(\n\t\t&data.abilities.$1[0],\n\t\t&mut abilities,
        \t\t&[\n\t\t\t$2\n\t\t]\n\t);\n\n"
            .replace("$1", ability_name)
            .replace("$2", &coords.join(",\n\t\t\t"))
    };

    for (_, champion_id) in champion_names {
        futures.push(tokio::spawn(async move {
            let path_name: String = format!("{}/{}.rs", writer_target, champion_id.to_lowercase());
            if let Ok(data) = fs::read_to_string(&path_name) {
                if data.contains("#![stable]") {
                    return;
                }
            }

            let mut autogenerated_content: String = String::from(
                "use super::{\n\tAbility, CdnChampion, Champion,
                \tHashMap, Target, extract_ability_damage\n};\n
                // #![auto_generated]\n\npub fn transform(data: CdnChampion) -> Champion {
                \tlet mut abilities = HashMap::<String, Ability>::new();\n\n",
            );

            let champion_data: CdnChampion =
                read_from_file(&format!("cache/cdn/champions/{}.json", champion_id));

            for (key, val) in champion_data.abilities.into_iterator() {
                let coords: Vec<String> = transform_ability(&key.to_uppercase(), val);
                if coords.len() > 0 {
                    autogenerated_content.push_str(&bind_function(&key, coords));
                }
            }

            autogenerated_content.push_str("\tdata.format(abilities)\n}");

            write_to_file(&path_name, autogenerated_content.trim().as_bytes());
        }));
    }

    for future in futures {
        _ = future.await;
    }
}

pub enum CacheError {
    IoError(io::Error),
    PathBufError(PathBuf),
    ParseIntError(ParseIntError),
}

fn load_json_map<K, V, F, G>(
    dir_path: &str,
    key_fn: F,
    convert_key: G,
) -> Result<HashMap<K, V>, CacheError>
where
    F: Fn(&PathBuf) -> Result<&str, CacheError>,
    G: Fn(&str) -> Result<K, CacheError>,
    V: DeserializeOwned,
    K: Eq + Hash,
{
    let mut map: HashMap<K, V> = HashMap::new();
    let read_dir: ReadDir = fs::read_dir(dir_path).map_err(CacheError::IoError)?;

    for entry in read_dir {
        let path_buf: PathBuf = entry.map_err(CacheError::IoError)?.path();
        let path_name: &str = path_buf
            .to_str()
            .ok_or_else(|| CacheError::PathBufError(path_buf.clone()))?;
        let file_key_str: &str = key_fn(&path_buf)?;
        let file_key: K = convert_key(file_key_str)?;
        let data: V = read_from_file(path_name);
        map.insert(file_key, data);
    }

    Ok(map)
}

fn load_optional_json<T>(path: &str, label: &str) -> T
where
    T: Default + DeserializeOwned,
{
    if Path::new(path).exists() {
        println!("fn[load_cache]: started loading {}", label);
        read_from_file::<T>(path)
    } else {
        T::default()
    }
}

// Syncronously loads all the cache that will live in memory through the entire execution
pub fn load_cache() -> Result<GlobalCache, CacheError> {
    println!("fn[load_cache]: started loading champion_files");
    let champions: HashMap<String, Champion> = load_json_map(
        "internal/champions",
        |path: &PathBuf| Ok(extract_file_name(path)),
        |s: &str| Ok(s.to_string()),
    )?;

    println!("fn[load_cache]: started loading item_files");
    let items: HashMap<usize, Item> = load_json_map(
        "internal/items",
        |path: &PathBuf| Ok(extract_file_name(path)),
        |s: &str| s.parse::<usize>().map_err(CacheError::ParseIntError),
    )?;

    let champion_names: HashMap<String, String> =
        load_optional_json("internal/champion_names.json", "champion_names");

    let meta_items: MetaItems = load_optional_json("internal/meta_items.json", "meta_items");

    let runes: HashMap<usize, Rune> = load_optional_json("internal/runes.json", "runes");

    Ok(GlobalCache {
        champions,
        items,
        runes,
        champion_names,
        meta_items,
    })
}

// Helper function to fetch data from the CDN. Returns a HashMap with `any` value.
async fn fetch_cdn_api(client: Client, path_name: &str) -> HashMap<String, Value> {
    let uri: String = env::var("CDN_ENDPOINT").expect("CDN_ENDPOINT is not set");
    let url: &String = &format!("{}/{}", uri.trim_end_matches('/'), path_name);

    println!("fetch_cdn_api: {}", url);

    let res: Response = client
        .get(url)
        .send()
        .await
        .expect("Failed to send request");

    let data: Value = res.json().await.expect("Failed to parse JSON");

    let result: &Map<String, Value> = data.as_object().expect("Failed to convert JSON to object");
    result.clone().into_iter().collect()
}

// Fetches DataDragon API from Riot Games. Only the final file path needs to be provided
async fn fetch_riot_api<T: DeserializeOwned>(client: Client, path_name: &str) -> T {
    let uri: String = env::var("DD_DRAGON_ENDPOINT").expect("DD_DRAGON_ENDPOINT is not set");
    let version: String = env::var("LOL_VERSION").expect("LOL_VERSION is not set");
    let language: String = env::var("LOL_LANGUAGE").expect("LOL_LANGUAGE is not set");
    let url: &String = &format!(
        "{}/{}/data/{}/{}.json",
        uri.trim_end_matches('/'),
        version,
        language,
        path_name
    );

    println!("fetch_riot_api: {}", url);

    let res: Response = client
        .get(url)
        .send()
        .await
        .expect("Failed to send request");

    let data: T = res.json::<T>().await.expect("Failed to parse JSON");
    data
}

// Updates files in `cache/riot` with the corresponding ones in the patch determined by `LOL_VERSION`
// Runs a maximum of 32 tokio threads at the same time
pub async fn update_riot_cache(client: Client) {
    let champions_json: RiotCdnStandard =
        fetch_riot_api::<RiotCdnStandard>(client.clone(), "champion").await;
    let mut champions_futures: Vec<JoinHandle<()>> = Vec::new();
    let champions_semaphore: Arc<Semaphore> = Arc::new(Semaphore::new(1 << 5));

    for (champion_id, _) in champions_json.data.clone() {
        let client: Client = client.clone();
        let semaphore: Arc<Semaphore> = champions_semaphore.clone();

        champions_futures.push(tokio::spawn(async move {
            let _permit: SemaphorePermit<'_> = semaphore.acquire().await.unwrap();

            let this_path_name: String = format!("cache/riot/champions/{}.json", champion_id);
            let this_champion_data: RiotCdnStandard =
                fetch_riot_api::<RiotCdnStandard>(client, &format!("champion/{}", champion_id))
                    .await;
            let data_field: HashMap<String, Value> = this_champion_data.data;
            let real_data: Value = data_field.get(&champion_id.to_string()).unwrap().clone();
            let strval: String = serde_json::to_string(&real_data).unwrap();
            write_to_file(&this_path_name, strval.as_bytes());
        }));
    }

    for champion_future in champions_futures {
        let _ = champion_future.await;
    }

    let champion_strval: String = serde_json::to_string_pretty(&champions_json).unwrap();
    let champion_bytes: &[u8] = champion_strval.as_bytes();
    write_to_file("cache/riot/champions.json", champion_bytes);

    let items_json: RiotCdnStandard =
        fetch_riot_api::<RiotCdnStandard>(client.clone(), "item").await;
    let mut items_futures: Vec<JoinHandle<()>> = Vec::new();

    for (item_id, item_data) in items_json.data.clone() {
        items_futures.push(task::spawn_blocking(move || {
            let this_path_name: String = format!("cache/riot/items/{}.json", item_id);
            let strval: String = serde_json::to_string(&item_data).unwrap();
            write_to_file(&this_path_name, strval.as_bytes());
        }));
    }

    for item_future in items_futures {
        let _ = item_future.await;
    }

    let item_strval: String = serde_json::to_string_pretty(&items_json).unwrap();
    let item_bytes: &[u8] = item_strval.as_bytes();
    write_to_file("cache/riot/items.json", item_bytes);

    let runes_json: Value = fetch_riot_api::<Value>(client, "runesReforged").await;
    let runes_strval: String = serde_json::to_string_pretty(&runes_json).unwrap();
    let runes_bytes: &[u8] = runes_strval.as_bytes();
    write_to_file("cache/riot/runes.json", runes_bytes);
}

// Recovers all the common builds for the current patch so the app can recommend builds to the user
// Average time to update is 2m30s. Making the outer loop a new task overloads the target website
// causing requests to timeout.
pub async fn get_meta_items(client: Client) {
    let champion_names: HashMap<String, String> = read_from_file("internal/champion_names.json");

    let positions = ["top", "jungle", "mid", "adc", "support"];
    let mut collected_results = HashMap::<String, HashMap<String, Vec<String>>>::new();

    for (_, name) in champion_names {
        let mut second_future = Vec::new();
        for position in positions {
            let champion_name: String = name.to_lowercase().clone();
            let client: Client = client.clone();
            second_future.push(tokio::spawn(async move {
                let endpoint: String = env::var("META_ENDPOINT").expect("META_ENDPOINT is not set");
                let url: String = format!("{}/{}/build/{}", endpoint, champion_name, position);

                let res = client
                    .get(url)
                    .send()
                    .await
                    .expect("Failed to send request");

                let mut result = HashMap::<String, Vec<String>>::new();

                let html: String = res.text().await.expect("Could not read response text");
                let document: Html = Html::parse_document(&html);
                let full_build: Selector =
                    Selector::parse(".m-1q4a7cx:nth-of-type(4) > div > div img")
                        .expect("Failed to parse nested selector");
                let situational_build: Selector = Selector::parse(".m-s76v8c > div > div img")
                    .expect("Failed to parse selector .m-s76v8c");

                let mut items: Vec<String> = Vec::<String>::new();
                let mut push_items = |selector: &Selector| {
                    for img in document.select(selector) {
                        if let Some(alt) = img.value().attr("alt") {
                            items.push(alt.to_string());
                        }
                    }
                };
                push_items(&full_build);
                push_items(&situational_build);
                result.insert(String::from(position), items);
                result
            }));
        }

        let mut collected_result: HashMap<String, Vec<String>> = HashMap::new();
        for result in second_future {
            println!("Fetching meta items for {}", name);
            collected_result.extend(result.await.unwrap());
        }
        collected_results.insert(name, collected_result);
    }

    write_to_file(
        "internal/meta_items.json",
        serde_json::to_string(&collected_results)
            .unwrap()
            .as_bytes(),
    );
}

// Takes an instance parameter and uses CDN API to get its data and save to file system.
pub async fn update_cdn_cache(client: Client, instance: &str) {
    let result: HashMap<String, Value> = fetch_cdn_api(client, &format!("{}.json", instance)).await;

    for (key, value) in result {
        let folder_name: String = format!("cache/cdn/{}", instance);
        task::spawn_blocking(move || {
            let path_name: String = format!("{}/{}.json", folder_name, key);
            let strval: String = value.to_string();
            write_to_file(&path_name, strval.as_bytes());
        });
    }
}

// Creates basic folders necessary to run the program. If one of these folders are not found,
// The program is likely to panic when an update is called.
pub fn setup_project_folders() {
    for dir in [
        "formulas",
        "img",
        "img/champions",
        "img/runes",
        "img/centered",
        "img/splash",
        "img/abilities",
        "img/items",
        "img/other",
        "img/stats",
        "cache",
        "cache/cdn",
        "cache/cdn/champions",
        "cache/cdn/items",
        "cache/riot",
        "cache/riot/champions",
        "cache/riot/items",
        "internal",
        "internal/items",
        "internal/champions",
    ] {
        let path: &Path = Path::new(dir);
        if !path.exists() {
            let error_msg: String = format!("Unable to create directory '{}'", dir);

            fs::create_dir_all(path).expect(&error_msg);
        }
    }
}

// Helper function to write files
pub fn write_to_file(path_name: &str, bytes: &[u8]) {
    println!("write_to_file: {}", path_name);

    let mut file = std::fs::File::create(path_name).expect("Unable to create file");
    file.write_all(bytes).expect("Unable to write data");
}

// Helper to read from files and parse the value to a struct
pub fn read_from_file<T: DeserializeOwned>(path_name: &str) -> T {
    println!("read_from_file: {}", path_name);

    let data: String = fs::read_to_string(path_name).expect(&format!(
        "Unable to read file [fn read_from_file<T: DeserializeOwned>(path_name: &str) -> T]: {}",
        path_name
    ));
    serde_json::from_str(&data).expect("Failed to parse JSON")
}

// Read every file in cache/cdn/champions folder and delegates
// the processing to generate_champion_file
pub fn setup_champion_cache() {
    let files: ReadDir =
        fs::read_dir("cache/cdn/champions").expect("Unable to read directory cache/cdn/champions");

    for file in files {
        let path_name: PathBuf = file.unwrap().path();
        task::spawn_blocking(move || {
            let strpath: &str = path_name
                .to_str()
                .expect("Failed to convert path to string at [setup_champion_cache]");
            println!("fn[setup_champion_cache]: {}", strpath);
            generate_champion_file(strpath);
        });
    }
}

// Not meant to be used frequently. Just a quick check for every
// patch to identify if a new damaging item was added
pub fn identify_damaging_items() {
    println!("fn[identify_damaging_items]");
    let contains_damage_outside_template = |text: &str| -> bool {
        let re: Regex = Regex::new(r"\{\{[^}]*\}\}").unwrap();
        let cleaned: Cow<'_, str> = re.replace_all(text, "");
        cleaned.contains("damage")
    };
    let files: ReadDir =
        fs::read_dir("cache/cdn/items").expect("Unable to read directory cache/cdn/items");
    let mut is_damaging: Vec<usize> = Vec::new();
    for file in files {
        let path_buf: PathBuf = file.unwrap().path();
        let path_name: &str = path_buf.to_str().unwrap();
        let result: CdnItem = read_from_file(path_name);
        if !result.shop.purchasable {
            continue;
        }
        let mut found_match: bool = false;
        if !result.passives.is_empty() {
            for passive in &result.passives {
                if contains_damage_outside_template(&passive.effects) {
                    found_match = true;
                }
            }
        }
        if !result.active.is_empty() {
            for active in &result.active {
                if contains_damage_outside_template(&active.effects) {
                    found_match = true;
                }
            }
        }
        if found_match {
            is_damaging.push(result.id);
        }
    }
    is_damaging.sort();
    write_to_file(
        "internal/damaging_items.json",
        serde_json::to_string_pretty(&is_damaging)
            .unwrap()
            .as_bytes(),
    );
}

// Replaces the content found in the files to a shorter and adapted version,
// initializes items as default, and Damaging stats must be added separately.
pub fn initialize_items() {
    println!("fn[initialize_items]");
    let non_zero = |val: f64| -> Option<f64> { if val == 0.0 { None } else { Some(val) } };

    let files: ReadDir =
        fs::read_dir("cache/cdn/items").expect("Unable to read directory cache/cdn/items");
    for file in files {
        task::spawn_blocking(move || {
            let path_buf: PathBuf = file.unwrap().path();
            let path_name: &str = path_buf.to_str().unwrap();

            println!("fn[initialize_items]: [initializing] {}", path_name);

            let cdn_item: CdnItem = read_from_file(path_name);

            let stats: &ItemStats = &cdn_item.stats;
            let mut item_stats: PartialStats = PartialStats::default();

            item_stats.ability_power = non_zero(stats.ability_power.flat);
            item_stats.armor = non_zero(stats.armor.flat);
            item_stats.attack_damage = non_zero(stats.attack_damage.flat);
            item_stats.attack_speed = non_zero(stats.attack_speed.flat);
            item_stats.critical_strike_chance = non_zero(stats.critical_strike_chance.flat);
            item_stats.critical_strike_damage = non_zero(stats.critical_strike_damage.flat);
            item_stats.health = non_zero(stats.health.flat);
            item_stats.lifesteal = non_zero(stats.lifesteal.flat);
            item_stats.magic_resistance = non_zero(stats.magic_resistance.flat);
            item_stats.mana = non_zero(stats.mana.flat);
            item_stats.movespeed = non_zero(stats.movespeed.flat);
            item_stats.omnivamp = non_zero(stats.omnivamp.flat);

            item_stats.armor_penetration_flat = non_zero(stats.armor_penetration.flat);
            item_stats.armor_penetration_percent = non_zero(stats.armor_penetration.percent);

            item_stats.magic_penetration_flat = non_zero(stats.magic_penetration.flat);
            item_stats.magic_penetration_percent = non_zero(stats.magic_penetration.percent);

            let get_damagelike_expr_from_vec = |source_vec: Vec<Effect>| -> Option<String> {
                source_vec
                    .get(0)
                    .map(|p: &Effect| extract_damagelike_expr(&p.effects))
                    .filter(|s: &String| !s.is_empty())
            };

            let damage_str: Option<String> = get_damagelike_expr_from_vec(cdn_item.passives)
                .or_else(|| get_damagelike_expr_from_vec(cdn_item.active));

            let (melee, ranged) = damage_str
                .as_ref()
                .filter(|s: &&String| s.chars().any(|c: char| c.is_ascii_digit()))
                .map(|s: &String| {
                    let item_dmg: DamageObject = DamageObject {
                        minimum_damage: Some(s.clone()),
                        maximum_damage: None,
                    };
                    (Some(item_dmg.clone()), Some(item_dmg))
                })
                .unwrap_or((None, None));

            let result: Item = Item {
                pretiffied_stats: HashMap::new(),
                name: cdn_item.name,
                gold: cdn_item.shop.prices.total,
                levelings: None,
                damage_type: None,
                damages_onhit: false,
                stats: item_stats,
                builds_from: cdn_item.builds_from,
                ranged,
                melee,
            };

            write_to_file(
                format!("internal/items/{}.json", cdn_item.id).as_str(),
                serde_json::to_string(&result).unwrap().as_bytes(),
            );
        });
    }
}

// Uses champion display name and converts to their respective ids, saving to internal
pub fn rewrite_champion_names() {
    println!("fn[rewrite_champion_names]");
    let files: ReadDir =
        fs::read_dir("cache/cdn/champions").expect("Unable to read directory cache/cdn/champions");

    let mut map: HashMap<String, String> = HashMap::<String, String>::new();

    for file in files {
        let path_buf: PathBuf = file.unwrap().path();
        let path_name: &str = path_buf.to_str().unwrap();
        let result: CdnChampion = read_from_file(path_name);
        let name: &str = extract_file_name(&path_buf);
        map.insert(result.name, name.to_string());
    }

    write_to_file(
        "internal/champion_names.json",
        serde_json::to_string(&map).unwrap().as_bytes(),
    );
}

// Automatically updates every champion in the game. New champions, or big updates to existing
// champions will need to be rewritten over time. If an error occurs while trying to update a
// champion, it will be skipped. Writes the resulting json to internal/{champion_name}.json
fn generate_champion_file(path_name: &str) {
    let result: CdnChampion = read_from_file(path_name);
    let name: &str = extract_file_name(Path::new(path_name));

    let champion: Option<Champion> = try_transform(&name.to_lowercase(), result);

    if !champion.is_none() {
        let string_value: String = serde_json::to_string_pretty(&champion).unwrap();

        write_to_file(
            &format!("internal/champions/{}.json", name),
            string_value.as_bytes(),
        );
    }
}

// `internal/items` folder must exist, as well as dir `cache/riot/items`. Takes every file
// and reads the "description" value from Riot `item.json` and parses its XML into a HashMap
// only updates the key `prettified_stats`. All the remaining content remains the same
pub async fn append_prettified_item_stats() {
    println!("fn[append_prettified_item_stats]");
    let files: ReadDir =
        fs::read_dir("cache/riot/items").expect("Unable to read directory cache/cdn/items");

    let mut item_futures = Vec::new();
    for file in files {
        item_futures.push(task::spawn_blocking(move || {
            let path_buf: PathBuf = file.unwrap().path();
            let name: &str = extract_file_name(&path_buf);
            let path_name: String = format!("cache/riot/items/{}.json", name);
            let pretiffied_stats: HashMap<String, Value> = pretiffy_item_stats(&path_name);
            let internal_path: String = format!("internal/items/{}.json", name);
            if !Path::new(&internal_path).exists() {
                println!("Item {} does not exist", name);
                return;
            }
            let mut current_content: Item = read_from_file(internal_path.as_str());
            current_content.pretiffied_stats = pretiffied_stats;
            let strval: String = serde_json::to_string(&current_content).unwrap();
            write_to_file(&internal_path, strval.as_bytes());
        }));
    }
    for future in item_futures {
        let _ = future.await;
    }
}

// When MetaItems are recovered, each item is written in the array with its name instead of ID
// This function replaces those names with IDs without changing the rest of the content.
// If one's ID is not found, it will remain unchanged
pub fn replace_item_names_with_ids() {
    println!("fn[replace_item_names_with_ids]");
    let mut meta_items: MetaItemValue<Value> = read_from_file("internal/meta_items.json");
    let items_folder: ReadDir =
        fs::read_dir("internal/items").expect("Failed to read items folder");

    // 4 `for` loops does not look pretty, but there's the only way to do it
    // 170 * 5 * 7 * 7 = 41650 expected iterations
    for entry in items_folder {
        let entry: DirEntry = entry.expect("Invalid DirEntry");
        let path: PathBuf = entry.path();
        let file_name: &str = extract_file_name(&path);
        let item_id: usize = file_name.parse::<usize>().unwrap_or(0);

        let internal_item: Item =
            read_from_file(path.to_str().expect("Failed to convert path to string"));

        for (_, positions) in meta_items.iter_mut() {
            for (_, items) in positions.iter_mut() {
                for item in items.iter_mut() {
                    if let Value::String(s) = item {
                        if s.to_lowercase() == internal_item.name.to_lowercase() {
                            *item = Value::Number(item_id.into());
                        }
                    }
                }
            }
        }
    }
    write_to_file(
        "internal/meta_items.json",
        serde_json::to_string_pretty(&meta_items)
            .unwrap()
            .as_bytes(),
    );
}

// Returns a new array with the coordinates where an ability was found according to CDN API
fn transform_ability(key: &str, abilities: &Vec<CdnAbility>) -> Vec<String> {
    let mut writer_keybinds: Vec<String> = Vec::<String>::new();

    for (ability_index, ability) in abilities.iter().enumerate() {
        for (effect_index, effect) in ability.effects.iter().enumerate() {
            for (leveling_index, leveling) in effect.leveling.iter().enumerate() {
                let attr: String = leveling
                    .attribute
                    .as_deref()
                    .unwrap_or_default()
                    .to_lowercase();

                if !attr.contains("damage") {
                    continue;
                }

                let suffix: &'static str = if attr.contains("monster") {
                    "_MONSTER"
                } else if attr.contains("bonus") {
                    "_BONUS"
                } else if attr.contains("maximum")
                    || attr.contains("total")
                    || attr.contains("increased")
                {
                    "_MAXIMUM"
                } else if attr.contains("minimum") {
                    "_MINIMUM"
                } else {
                    ""
                };

                let base_key: String = format!(
                    "{}_{}_{}_{}",
                    key, ability_index, effect_index, leveling_index
                );
                let final_key: String = format!("{}{}", base_key, suffix);

                writer_keybinds.push(format!(
                    "({}, {}, \"{}\", {})",
                    effect_index,
                    leveling_index,
                    final_key,
                    if suffix.contains("MAX") {
                        "Target::MAXIMUM"
                    } else {
                        "Target::MINIMUM"
                    }
                ));
            }
        }
    }
    writer_keybinds
}

// Returns the value that will be added to key `pretiffied_stats` for each item.
// Depends on Riot API `item.json` and requires manual maintainance if a new XML tag is added
fn pretiffy_item_stats(path_name: &str) -> HashMap<String, Value> {
    let data: RiotCdnItem = read_from_file(path_name);
    let mut result: HashMap<String, Value> = HashMap::new();

    // #![manual_impl]
    let tag_regex: Regex = Regex::new(r#"<(attention|buffedStat|nerfedStat|ornnBonus)>(.*?)<\/(attention|buffedStat|nerfedStat|ornnBonus)>"#).unwrap();
    let line_regex: Regex = Regex::new(r"(.*?)<br>").unwrap();
    let percent_prefix_regex: Regex = Regex::new(r"^\s*\d+\s*%?\s*").unwrap();
    let tag_strip_regex: Regex = Regex::new(r"<\/?[^>]+(>|$)").unwrap();

    let u: [&'static str; 4] = ["buffedStat", "nerfedStat", "attention", "ornnBonus"];
    let k: [&'static str; 2] = ["Cooldown", "Healing"];

    let lines: Vec<_> = line_regex.captures_iter(&data.description).collect();
    let mut line_index: usize = 0;

    for caps in tag_regex.captures_iter(&data.description) {
        let t: &str = &caps[1];
        let v: String = caps[2].replace('%', "");
        let mut n: Option<String> = None;
        if line_index < lines.len() {
            let cleaned: String = tag_strip_regex
                .replace_all(&lines[line_index][1], "")
                .trim()
                .to_string();
            if !cleaned.is_empty() {
                n = Some(cleaned);
            }
            line_index += 1;
        }
        if u.contains(&t) {
            if let Some(n_val) = &n {
                let j: String = percent_prefix_regex.replace(n_val, "").trim().to_string();
                if !j.is_empty() {
                    let is_percent: bool = caps[2].contains('%');
                    let value: Value =
                        if k.iter().any(|&keyword| n_val.contains(keyword)) && is_percent {
                            Value::String(format!("{}%", v))
                        } else {
                            match v.parse::<f64>() {
                                Ok(num) => Value::from(num),
                                Err(_) => continue,
                            }
                        };
                    result.insert(j, value);
                }
            }
        }
    }
    result
}
