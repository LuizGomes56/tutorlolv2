use crate::model::application::GlobalCache;
use crate::model::champions::{CdnAbility, CdnChampion, Champion};
use crate::model::internal::MetaItems;
use crate::model::items::{CdnItem, Effect, Item, PartialStats};
use crate::model::realtime::DamageObject;
use crate::model::riot::{RiotCdnItem, RiotCdnStandard};
use crate::model::runes::Rune;
use regex::Regex;
use scraper::{Html, Selector};
use serde::de::DeserializeOwned;
use serde_json::Value;
use std::env;
use std::{
    collections::HashMap,
    fs,
    io::Write,
    path::{Path, PathBuf},
};
use tokio::task;

use super::helpers::extract_damagelike_expr;
use super::*;

type MetaItemValue<T> = HashMap<String, HashMap<String, Vec<T>>>;

// Files will be generated automatically, but checked manually until it is confirmed that the desired
// format was succesfully generated. Once it is done, it will be added a comment to the header to
// prevent the generator from editing that file. "#![mark_checked]".
pub async fn generate_writer_files() {
    let champion_names =
        read_from_file::<HashMap<String, String>>("src/internal/champion_names.json");

    let mut futures = Vec::new();

    let bind_function = |ability_name: &str, coords: Vec<String>| {
        "get_from_pattern(&data.abilities.$1[0], &mut abilities, &[$2]);"
            .replace("$1", ability_name)
            .replace("$2", &coords.join(","))
    };

    for (_, champion_id) in champion_names {
        futures.push(tokio::spawn(async move {
            let path_name = format!("src/writers/{}.rs", champion_id.to_lowercase());
            if let Ok(data) = fs::read_to_string(&path_name) {
                if data.get(0..25).map_or(false, |s| s.contains("#![mark_checked]")) {
                    return;
                }
            }

            let mut autogenerated_content = String::from("#![allow(dead_code)]\n\nuse super::{Ability, CdnChampion, Champion, HashMap, IterationTarget, get_from_pattern};\n\npub fn transform(data: CdnChampion) -> Champion {\nlet mut abilities = HashMap::<String, Ability>::new();\n\n");

            let champion_data =
                read_from_file::<CdnChampion>(&format!("src/cache/cdn/champions/{}.json", champion_id));

            for (key, val) in champion_data.abilities.into_iterator() {
                let coords = transform_ability(&key.to_uppercase(), val);
                if coords.len() > 0 {
                    autogenerated_content.push_str(&bind_function(&key, coords)); 
                }
            }

            autogenerated_content.push_str("data.format(abilities)\n}");

            write_to_file(&path_name, autogenerated_content.trim().as_bytes());
        }));
    }

    for future in futures {
        _ = future.await;
    }
}

pub fn load_cache() -> GlobalCache {
    println!("load_cache: started loading champion_files");

    let champion_files: Vec<PathBuf> = fs::read_dir("src/internal/champions")
        .expect("Failed to read champions")
        .map(|e| e.unwrap().path())
        .collect();

    let champion_names =
        read_from_file::<HashMap<String, String>>("src/internal/champion_names.json");

    println!("load_cache: started loading item_files");

    let item_files: Vec<PathBuf> = fs::read_dir("src/internal/items")
        .expect("Failed to read items")
        .map(|e| e.unwrap().path())
        .collect();


    println!("load_cache: started loading meta_items");

    let meta_items = read_from_file::<MetaItems>("src/internal/meta_items.json");

    let mut items = HashMap::with_capacity(item_files.len());
    for path_name in item_files {
        let data = read_from_file::<Item>(
            path_name
                .to_str()
                .expect("Failed to convert path to string"),
        );
        let name = extract_file_name(&path_name);
        match name.parse::<usize>() {
            Ok(item_id) => {
                items.insert(item_id, data);
            }
            Err(e) => {
                println!("Failed to parse item id: {}", e);
                continue;
            }
        }
    }

    println!("load_cache: started loading runes");

    let runes = read_from_file::<HashMap<usize, Rune>>("src/internal/runes.json");

    let mut champions = HashMap::with_capacity(champion_files.len());
    for path_name in champion_files {
        let data = read_from_file::<Champion>(
            path_name
                .to_str()
                .expect("Failed to convert path to string"),
        );
        let name = extract_file_name(&path_name);
        champions.insert(String::from(name), data);
    }

    GlobalCache {
        champions,
        items,
        runes,
        champion_names,
        meta_items,
    }
}

// Helper function to fetch data from the CDN. ReturnTypes are not strongly typed.
async fn fetch_cdn_api(path_name: &str) -> HashMap<String, Value> {
    let uri = env::var("CDN_ENDPOINT").expect("CDN_ENDPOINT is not set");
    let client = reqwest::Client::new();
    let url = &format!("{}/{}", uri.trim_end_matches('/'), path_name);

    println!("fetch_cdn_api: {}", url);

    let res = client
        .get(url)
        .send()
        .await
        .expect("Failed to send request");

    let data: Value = res.json().await.expect("Failed to parse JSON");

    let result = data.as_object().expect("Failed to convert JSON to object");

    result.clone().into_iter().collect()
}

async fn fetch_riot_api<T: DeserializeOwned>(path_name: &str) -> T {
    let uri = env::var("DD_DRAGON_ENDPOINT").expect("DD_DRAGON_ENDPOINT is not set");
    let version = env::var("LOL_VERSION").expect("LOL_VERSION is not set");
    let language = env::var("LOL_LANGUAGE").expect("LOL_LANGUAGE is not set");
    let client = reqwest::Client::new();
    let url =&format!(
            "{}/{}/data/{}/{}.json",
            uri.trim_end_matches('/'),
            version,
            language,
            path_name
        );  

    println!("fetch_riot_api: {}", url);

    let res = client
        .get(url)
        .send()
        .await
        .expect("Failed to send request");

    let data = res.json::<T>().await.expect("Failed to parse JSON");
    data
}

pub async fn update_riot_cache() {
    let champions_json = fetch_riot_api::<RiotCdnStandard>("champion").await;
    let mut champions_futures = Vec::new();

    for (champion_id, _) in champions_json.data.clone() {
        champions_futures.push(tokio::spawn(async move {
            let this_path_name = format!("src/cache/riot/champions/{}.json", champion_id);
            let this_champion_data =
                fetch_riot_api::<RiotCdnStandard>(&format!("champion/{}", champion_id)).await;
            let data_field = this_champion_data.data;
            let real_data = data_field.get(&champion_id.to_string()).unwrap().clone();
            let strval = serde_json::to_string(&real_data).unwrap();
            write_to_file(&this_path_name, strval.as_bytes());
        }));
    }

    for champion_future in champions_futures {
        let _ = champion_future.await;
    }

    let champion_strval = serde_json::to_string_pretty(&champions_json).unwrap();
    let champion_bytes = champion_strval.as_bytes();
    write_to_file("src/cache/riot/champions.json", champion_bytes);

    let items_json = fetch_riot_api::<RiotCdnStandard>("item").await;
    let mut items_futures = Vec::new();

    for (item_id, item_data) in items_json.data.clone() {
        items_futures.push(task::spawn_blocking(move || {
            let this_path_name = format!("src/cache/riot/items/{}.json", item_id);
            let strval = serde_json::to_string(&item_data).unwrap();
            write_to_file(&this_path_name, strval.as_bytes());
        }));
    }

    for item_future in items_futures {
        let _ = item_future.await;
    }

    let item_strval = serde_json::to_string_pretty(&items_json).unwrap();
    let item_bytes = item_strval.as_bytes();
    write_to_file("src/cache/riot/items.json", item_bytes);

    let runes_json = fetch_riot_api::<Value>("runesReforged").await;
    let runes_strval = serde_json::to_string_pretty(&runes_json).unwrap();
    let runes_bytes = runes_strval.as_bytes();
    write_to_file("src/cache/riot/runes.json", runes_bytes);
}

// Recovers all the common builds for the current patch so the app can recommend builds to the user
// Average time to update is 2m30s. Making the outer loop a new task overloads the target website
// causing requests to timeout.
pub async fn get_meta_items() {
    let client_arc = reqwest::Client::new();

    let champion_names =
        read_from_file::<HashMap<String, String>>("src/internal/champion_names.json");

    let positions = ["top", "jungle", "mid", "adc", "support"];
    let mut collected_results = HashMap::<String, HashMap<String, Vec<String>>>::new();

    for (_, name) in champion_names {
        let mut second_future = Vec::new();
        for position in positions {
            let champion_name = name.to_lowercase().clone();
            let client = client_arc.clone();
            second_future.push(tokio::spawn(async move {
                let endpoint = env::var("META_ENDPOINT").expect("META_ENDPOINT is not set");
                let url = format!("{}/{}/build/{}", endpoint, champion_name, position);

                let res = client
                    .get(url)
                    .send()
                    .await
                    .expect("Failed to send request");

                let mut result = HashMap::<String, Vec<String>>::new();

                let html = res.text().await.expect("Could not read response text");
                let document = Html::parse_document(&html);
                let full_build = Selector::parse(".m-1q4a7cx:nth-of-type(4) > div > div img")
                    .expect("Failed to parse nested selector");
                let situational_build = Selector::parse(".m-s76v8c > div > div img")
                    .expect("Failed to parse selector .m-s76v8c");

                let mut items = Vec::<String>::new();
                let mut push_items = |selector: &Selector| {
                    for img in document.select(selector) {
                        if let Some(alt) = img.value().attr("alt") {
                            items.push(alt.to_string());
                        }
                    }
                };
                push_items(&full_build);
                push_items(&situational_build);
                result.insert(String::from(position), items);
                result
            }));
        }

        let mut collected_result = HashMap::new();
        for result in second_future {
            println!("Fetching meta items for {}", name);
            collected_result.extend(result.await.unwrap());
        }
        collected_results.insert(name, collected_result);
    }

    write_to_file(
        "src/internal/meta_items.json",
        serde_json::to_string(&collected_results)
            .unwrap()
            .as_bytes(),
    );
}

pub async fn update_instances(instance: &str) {
    let result = fetch_cdn_api(&format!("{}.json", instance)).await;

    for (key, value) in result {
        let folder_name = format!("src/cache/cdn/{}", instance);
        task::spawn_blocking(move || {
            let path_name = format!("{}/{}.json", folder_name, key);
            let strval = value.to_string();
            write_to_file(&path_name, strval.as_bytes());
        });
    }
}

// Creates basic folders necessary to run the program. If one of these folders are not found,
// The program is likely to panic when an update is called.
pub fn setup_project_folders() {
    for dir in [
        "src",
        "src/img",
        "src/img/champions",
        "src/img/runes",
        "src/img/centered",
        "src/img/splash",
        "src/img/abilities",
        "src/img/items",
        "src/img/other",
        "src/img/stats",
        "src/cache",
        "src/cache/cdn",
        "src/cache/cdn/champions",
        "src/cache/cdn/items",
        "src/cache/riot",
        "src/cache/riot/champions",
        "src/cache/riot/items",
        "src/internal",
        "src/internal/items",
        "src/internal/champions",
        "src/writers",
    ] {
        let path = Path::new(dir);
        if !path.exists() {
            let error_msg = format!("Unable to create directory '{}'", dir);

            fs::create_dir_all(path).expect(&error_msg);
        }
    }
}

// Helper function to write files
pub fn write_to_file(path_name: &str, bytes: &[u8]) {
    println!("write_to_file: {}", path_name);

    let mut file = std::fs::File::create(path_name).expect("Unable to create file");
    file.write_all(bytes).expect("Unable to write data");
}

// Helper to read from files and parse the value to a struct
pub fn read_from_file<T: DeserializeOwned>(path_name: &str) -> T {
    println!("read_from_file: {}", path_name);
    
    let data = fs::read_to_string(path_name).expect(&format!("Unable to read file: {}", path_name));
    serde_json::from_str(&data).expect("Failed to parse JSON")
}

// Read every file in src/cache/cdn/champions folder and delegates the processing to generate_champion_file
pub fn setup_champion_cache() {
    let files = fs::read_dir("src/cache/cdn/champions")
        .expect("Unable to read directory src/cache/cdn/champions");

    for file in files {
        let path_name = file.unwrap().path();
        task::spawn_blocking(move || {
            generate_champion_file(
                path_name
                    .to_str()
                    .expect("Failed to convert path to string"),
            );
        });
    }
}

// Not meant to be used frequently. Just a quick check for every
// patch to identify if a new damaging item was added
pub fn identify_damaging_items() {
    let contains_damage_outside_template = |text: &str| -> bool {
        let re = Regex::new(r"\{\{[^}]*\}\}").unwrap();
        let cleaned = re.replace_all(text, "");
        cleaned.contains("damage")
    };
    let files =
        fs::read_dir("src/cache/cdn/items").expect("Unable to read directory src/cache/cdn/items");
    let mut is_damaging = Vec::new();
    for file in files {
        let path_buf = file.unwrap().path();
        let path_name = path_buf.to_str().unwrap();
        let result = read_from_file::<CdnItem>(path_name);
        if !result.shop.purchasable {
            continue;
        }
        let mut found_match = false;
        if !result.passives.is_empty() {
            for passive in &result.passives {
                if contains_damage_outside_template(&passive.effects) {
                    found_match = true;
                }
            }
        }
        if !result.active.is_empty() {
            for active in &result.active {
                if contains_damage_outside_template(&active.effects) {
                    found_match = true;
                }
            }
        }
        if found_match {
            is_damaging.push(result.id);
        }
    }
    is_damaging.sort();
    write_to_file(
        "src/internal/damaging_items.json",
        serde_json::to_string_pretty(&is_damaging)
            .unwrap()
            .as_bytes(),
    );
}

// Replaces the content found in the files to a shorter and adapted version,
// initializes items as default, and Damaging stats must be added separately.
pub fn initialize_items() {
    let non_zero = |val: f64| -> Option<f64> { if val == 0.0 { None } else { Some(val) } };

    let files =
        fs::read_dir("src/cache/cdn/items").expect("Unable to read directory src/cache/cdn/items");
    for file in files {
        task::spawn_blocking(move || {
            let path_buf = file.unwrap().path();
            let path_name = path_buf.to_str().unwrap();
            let cdn_item = read_from_file::<CdnItem>(path_name);

            let stats = &cdn_item.stats;
            let mut item_stats = PartialStats::default();

            item_stats.ability_power = non_zero(stats.ability_power.flat);
            item_stats.armor = non_zero(stats.armor.flat);
            item_stats.attack_damage = non_zero(stats.attack_damage.flat);
            item_stats.attack_speed = non_zero(stats.attack_speed.flat);
            item_stats.critical_strike_chance = non_zero(stats.critical_strike_chance.flat);
            item_stats.critical_strike_damage = non_zero(stats.critical_strike_damage.flat);
            item_stats.health = non_zero(stats.health.flat);
            item_stats.lifesteal = non_zero(stats.lifesteal.flat);
            item_stats.magic_resistance = non_zero(stats.magic_resistance.flat);
            item_stats.mana = non_zero(stats.mana.flat);
            item_stats.movespeed = non_zero(stats.movespeed.flat);
            item_stats.omnivamp = non_zero(stats.omnivamp.flat);

            item_stats.armor_penetration_flat = non_zero(stats.armor_penetration.flat);
            item_stats.armor_penetration_percent = non_zero(stats.armor_penetration.percent);

            item_stats.magic_penetration_flat = non_zero(stats.magic_penetration.flat);
            item_stats.magic_penetration_percent = non_zero(stats.magic_penetration.percent);

            let get_damagelike_expr_from_vec = |source_vec: Vec<Effect>| -> Option<String> {
                source_vec
                    .get(0)
                    .map(|p| extract_damagelike_expr(&p.effects))
                    .filter(|s| !s.is_empty())
            };

            let damage_str = get_damagelike_expr_from_vec(cdn_item.passives)
                .or_else(|| get_damagelike_expr_from_vec(cdn_item.active));

            let (melee, ranged) = damage_str
                .as_ref()
                .filter(|s| s.chars().any(|c| c.is_ascii_digit()))
                .map(|s| {
                    let item_dmg = DamageObject {
                        minimum_damage: Some(s.clone()),
                        maximum_damage: None,
                    };
                    (Some(item_dmg.clone()), Some(item_dmg))
                })
                .unwrap_or((None, None));

            let result = Item {
                pretiffied_stats: HashMap::new(),
                name: cdn_item.name,
                gold: cdn_item.shop.prices.total,
                levelings: None,
                damage_type: None,
                damages_onhit: false,
                stats: item_stats,
                builds_from: cdn_item.builds_from,
                ranged,
                melee,
            };

            write_to_file(
                format!("src/internal/items/{}.json", cdn_item.id).as_str(),
                serde_json::to_string(&result).unwrap().as_bytes(),
            );
        });
    }
}

// Uses champion display name and converts to their respective ids, saving to internal
pub fn rewrite_champion_names() {
    let files = fs::read_dir("src/cache/cdn/champions")
        .expect("Unable to read directory src/cache/cdn/champions");

    let mut map = HashMap::<String, String>::new();

    for file in files {
        let path_buf = file.unwrap().path();
        let path_name = path_buf.to_str().unwrap();
        let result = read_from_file::<CdnChampion>(path_name);
        let name = extract_file_name(&path_buf);
        map.insert(result.name, name.to_string());
    }

    write_to_file(
        "src/internal/champion_names.json",
        serde_json::to_string(&map).unwrap().as_bytes(),
    );
}

// Automatically updates every champion in the game. New champions, or big updates to existing
// champions will need to be rewritten over time. If an error occurs while trying to update a
// champion, it will be skipped. Writes the resulting json to internal/{champion_name}.json
fn generate_champion_file(path_name: &str) {
    let result = read_from_file::<CdnChampion>(path_name);
    let name = extract_file_name(Path::new(path_name));

    let champion: Option<Champion> = match name {
        "Aatrox" => Some(aatrox::transform(result)),
        "Ahri" => Some(ahri::transform(result)),
        "Akali" => Some(akali::transform(result)),
        "Akshan" => Some(akshan::transform(result)),
        "Alistar" => Some(alistar::transform(result)),
        "Ambessa" => Some(ambessa::transform(result)),
        "Amumu" => Some(amumu::transform(result)),
        "Anivia" => Some(anivia::transform(result)),
        "Annie" => Some(annie::transform(result)),
        "Aphelios" => Some(aphelios::transform(result)),
        "Ashe" => Some(ashe::transform(result)),
        "AurelionSol" => Some(aurelionsol::transform(result)),
        "Aurora" => Some(aurora::transform(result)),
        "Azir" => Some(azir::transform(result)),
        "Bard" => Some(bard::transform(result)),
        "Belveth" => Some(belveth::transform(result)),
        "Blitzcrank" => Some(blitzcrank::transform(result)),
        "Brand" => Some(brand::transform(result)),
        "Braum" => Some(braum::transform(result)),
        "Briar" => Some(briar::transform(result)),
        "Caitlyn" => Some(caitlyn::transform(result)),
        "Camille" => Some(camille::transform(result)),
        "Cassiopeia" => Some(cassiopeia::transform(result)),
        "Chogath" => Some(chogath::transform(result)),
        "Corki" => Some(corki::transform(result)),
        "Darius" => Some(darius::transform(result)),
        "Diana" => Some(diana::transform(result)),
        "Draven" => Some(draven::transform(result)),
        "DrMundo" => Some(drmundo::transform(result)),
        "Ekko" => Some(ekko::transform(result)),
        "Elise" => Some(elise::transform(result)),
        "Evelynn" => Some(evelynn::transform(result)),
        "Ezreal" => Some(ezreal::transform(result)),
        "Fiddlesticks" => Some(fiddlesticks::transform(result)),
        "Fiora" => Some(fiora::transform(result)),
        "Fizz" => Some(fizz::transform(result)),
        "Galio" => Some(galio::transform(result)),
        "Gangplank" => Some(gangplank::transform(result)),
        "Garen" => Some(garen::transform(result)),
        "Gnar" => Some(gnar::transform(result)),
        "Gragas" => Some(gragas::transform(result)),
        "Graves" => Some(graves::transform(result)),
        "Gwen" => Some(gwen::transform(result)),
        "Hecarim" => Some(hecarim::transform(result)),
        "Heimerdinger" => Some(heimerdinger::transform(result)),
        "Hwei" => Some(hwei::transform(result)),
        "Illaoi" => Some(illaoi::transform(result)),
        "Irelia" => Some(irelia::transform(result)),
        "Ivern" => Some(ivern::transform(result)),
        "Janna" => Some(janna::transform(result)),
        "JarvanIV" => Some(jarvaniv::transform(result)),
        "Jax" => Some(jax::transform(result)),
        "Jayce" => Some(jayce::transform(result)),
        "Jhin" => Some(jhin::transform(result)),
        "Jinx" => Some(jinx::transform(result)),
        "Kaisa" => Some(kaisa::transform(result)),
        "Kalista" => Some(kalista::transform(result)),
        "Karma" => Some(karma::transform(result)),
        "Karthus" => Some(karthus::transform(result)),
        "Kassadin" => Some(kassadin::transform(result)),
        "Katarina" => Some(katarina::transform(result)),
        "Kayle" => Some(kayle::transform(result)),
        "Kayn" => Some(kayn::transform(result)),
        "Kennen" => Some(kennen::transform(result)),
        "Khazix" => Some(khazix::transform(result)),
        "Kindred" => Some(kindred::transform(result)),
        "Kled" => Some(kled::transform(result)),
        "KogMaw" => Some(kogmaw::transform(result)),
        "KSante" => Some(ksante::transform(result)),
        "Leblanc" => Some(leblanc::transform(result)),
        "LeeSin" => Some(leesin::transform(result)),
        "Leona" => Some(leona::transform(result)),
        "Lillia" => Some(lillia::transform(result)),
        "Lissandra" => Some(lissandra::transform(result)),
        "Lucian" => Some(lucian::transform(result)),
        "Lulu" => Some(lulu::transform(result)),
        "Lux" => Some(lux::transform(result)),
        "Malphite" => Some(malphite::transform(result)),
        "Malzahar" => Some(malzahar::transform(result)),
        "Maokai" => Some(maokai::transform(result)),
        "MasterYi" => Some(masteryi::transform(result)),
        "Mel" => Some(mel::transform(result)),
        "Milio" => Some(milio::transform(result)),
        "MissFortune" => Some(missfortune::transform(result)),
        "MonkeyKing" => Some(monkeyking::transform(result)),
        "Mordekaiser" => Some(mordekaiser::transform(result)),
        "Morgana" => Some(morgana::transform(result)),
        "Naafiri" => Some(naafiri::transform(result)),
        "Nami" => Some(nami::transform(result)),
        "Nasus" => Some(nasus::transform(result)),
        "Nautilus" => Some(nautilus::transform(result)),
        "Neeko" => Some(neeko::transform(result)),
        "Nidalee" => Some(nidalee::transform(result)),
        "Nilah" => Some(nilah::transform(result)),
        "Nocturne" => Some(nocturne::transform(result)),
        "Nunu" => Some(nunu::transform(result)),
        "Olaf" => Some(olaf::transform(result)),
        "Orianna" => Some(orianna::transform(result)),
        "Ornn" => Some(ornn::transform(result)),
        "Pantheon" => Some(pantheon::transform(result)),
        "Poppy" => Some(poppy::transform(result)),
        "Pyke" => Some(pyke::transform(result)),
        "Qiyana" => Some(qiyana::transform(result)),
        "Quinn" => Some(quinn::transform(result)),
        "Rakan" => Some(rakan::transform(result)),
        "Rammus" => Some(rammus::transform(result)),
        "RekSai" => Some(reksai::transform(result)),
        "Rell" => Some(rell::transform(result)),
        "Renata" => Some(renata::transform(result)),
        "Renekton" => Some(renekton::transform(result)),
        "Rengar" => Some(rengar::transform(result)),
        "Riven" => Some(riven::transform(result)),
        "Rumble" => Some(rumble::transform(result)),
        "Ryze" => Some(ryze::transform(result)),
        "Samira" => Some(samira::transform(result)),
        "Sejuani" => Some(sejuani::transform(result)),
        "Senna" => Some(senna::transform(result)),
        "Seraphine" => Some(seraphine::transform(result)),
        "Sett" => Some(sett::transform(result)),
        "Shaco" => Some(shaco::transform(result)),
        "Shen" => Some(shen::transform(result)),
        "Shyvana" => Some(shyvana::transform(result)),
        "Singed" => Some(singed::transform(result)),
        "Sion" => Some(sion::transform(result)),
        "Sivir" => Some(sivir::transform(result)),
        "Skarner" => Some(skarner::transform(result)),
        "Smolder" => Some(smolder::transform(result)),
        "Sona" => Some(sona::transform(result)),
        "Soraka" => Some(soraka::transform(result)),
        "Swain" => Some(swain::transform(result)),
        "Sylas" => Some(sylas::transform(result)),
        "Syndra" => Some(syndra::transform(result)),
        "TahmKench" => Some(tahmkench::transform(result)),
        "Taliyah" => Some(taliyah::transform(result)),
        "Talon" => Some(talon::transform(result)),
        "Taric" => Some(taric::transform(result)),
        "Teemo" => Some(teemo::transform(result)),
        "Thresh" => Some(thresh::transform(result)),
        "Tristana" => Some(tristana::transform(result)),
        "Trundle" => Some(trundle::transform(result)),
        "Tryndamere" => Some(tryndamere::transform(result)),
        "TwistedFate" => Some(twistedfate::transform(result)),
        "Twitch" => Some(twitch::transform(result)),
        "Udyr" => Some(udyr::transform(result)),
        "Urgot" => Some(urgot::transform(result)),
        "Varus" => Some(varus::transform(result)),
        "Vayne" => Some(vayne::transform(result)),
        "Veigar" => Some(veigar::transform(result)),
        "Velkoz" => Some(velkoz::transform(result)),
        "Vex" => Some(vex::transform(result)),
        "Vi" => Some(vi::transform(result)),
        "Viego" => Some(viego::transform(result)),
        "Viktor" => Some(viktor::transform(result)),
        "Vladimir" => Some(vladimir::transform(result)),
        "Volibear" => Some(volibear::transform(result)),
        "Warwick" => Some(warwick::transform(result)),
        "Xayah" => Some(xayah::transform(result)),
        "Xerath" => Some(xerath::transform(result)),
        "XinZhao" => Some(xinzhao::transform(result)),
        "Yasuo" => Some(yasuo::transform(result)),
        "Yone" => Some(yone::transform(result)),
        "Yorick" => Some(yorick::transform(result)),
        "Yuumi" => Some(yuumi::transform(result)),
        "Zac" => Some(zac::transform(result)),
        "Zed" => Some(zed::transform(result)),
        "Zeri" => Some(zeri::transform(result)),
        "Ziggs" => Some(ziggs::transform(result)),
        "Zilean" => Some(zilean::transform(result)),
        "Zoe" => Some(zoe::transform(result)),
        "Zyra" => Some(zyra::transform(result)),
        _ => None,
    };

    if !champion.is_none() {
        let bytes = serde_json::to_string(&champion).unwrap();

        write_to_file(
            &format!("src/internal/champions/{}.json", name),
            bytes.as_bytes(),
        );
    }
}

pub async fn append_prettified_item_stats() {
    let files =
        fs::read_dir("src/cache/riot/items").expect("Unable to read directory src/cache/cdn/items");

    let mut item_futures = Vec::new();
    for file in files {
        item_futures.push(task::spawn_blocking(move || {
            let path_buf = file.unwrap().path();
            let name = extract_file_name(&path_buf);
            let path_name = format!("src/cache/riot/items/{}.json", name);
            let pretiffied_stats = pretiffy_item_stats(&path_name);
            let internal_path = format!("src/internal/items/{}.json", name);
            if !Path::new(&internal_path).exists() {
                println!("Item {} does not exist", name);
                return;
            }
            let mut current_content = read_from_file::<Item>(internal_path.as_str());
            current_content.pretiffied_stats = pretiffied_stats;
            let strval = serde_json::to_string(&current_content).unwrap();
            write_to_file(&internal_path, strval.as_bytes());
        }));
    }
    for future in item_futures {
        let _ = future.await;
    }
}

pub fn replace_item_names_with_ids() {
    let mut meta_items = read_from_file::<MetaItemValue<Value>>("src/internal/meta_items.json");
    let items_folder = fs::read_dir("src/internal/items").expect("Failed to read items folder");

    for entry in items_folder {
        let entry = entry.expect("Invalid DirEntry");
        let path = entry.path();
        let file_name = extract_file_name(&path);
        let item_id = file_name.parse::<usize>().unwrap_or(0);

        let internal_item =
            read_from_file::<Item>(path.to_str().expect("Failed to convert path to string"));

        for (_, positions) in meta_items.iter_mut() {
            for (_, items) in positions.iter_mut() {
                for item in items.iter_mut() {
                    if let Value::String(s) = item {
                        if s == &internal_item.name {
                            *item = Value::Number(item_id.into());
                        }
                    }
                }
            }
        }
    }
    write_to_file(
        "src/internal/meta_items.json",
        serde_json::to_string_pretty(&meta_items)
            .unwrap()
            .as_bytes(),
    );
}

fn transform_ability(key: &str, abilities: &Vec<CdnAbility>) -> Vec<String> {
    let mut writer_keybinds = Vec::<String>::new();

    for (ability_index, ability) in abilities.iter().enumerate() {
        for (effect_index, effect) in ability.effects.iter().enumerate() {
            for (leveling_index, leveling) in effect.leveling.iter().enumerate() {
                let attr = leveling
                    .attribute
                    .as_deref()
                    .unwrap_or_default()
                    .to_lowercase();

                if !attr.contains("damage") {
                    continue;
                }

                let suffix = if attr.contains("monster") {
                    "_MONSTER"
                } else if attr.contains("bonus") {
                    "_BONUS"
                } else if attr.contains("maximum")
                    || attr.contains("total")
                    || attr.contains("increased")
                {
                    "_MAXIMUM"
                } else if attr.contains("minimum") {
                    "_MINIMUM"
                } else {
                    ""
                };

                let base_key = format!("{}_{}_{}", key, ability_index, effect_index);
                let final_key = format!("{}{}", base_key, suffix);

                writer_keybinds.push(format!(
                    "({}, {}, \"{}\", {})",
                    effect_index,
                    leveling_index,
                    final_key,
                    if suffix.contains("MAX") {
                        "IterationTarget::MAXIMUM"
                    } else {
                        "IterationTarget::MINIMUM"
                    }
                ));
            }
        }
    }
    writer_keybinds
}

fn pretiffy_item_stats(path_name: &str) -> HashMap<String, Value> {
    let data = read_from_file::<RiotCdnItem>(path_name);
    let mut result = HashMap::new();

    let tag_regex = Regex::new(r#"<(attention|buffedStat|nerfedStat|ornnBonus)>(.*?)<\/(attention|buffedStat|nerfedStat|ornnBonus)>"#).unwrap();
    let line_regex = Regex::new(r"(.*?)<br>").unwrap();
    let percent_prefix_regex = Regex::new(r"^\s*\d+\s*%?\s*").unwrap();
    let tag_strip_regex = Regex::new(r"<\/?[^>]+(>|$)").unwrap();

    let u = ["buffedStat", "nerfedStat", "attention", "ornnBonus"];
    let k = ["Cooldown", "Healing"];

    let lines: Vec<_> = line_regex.captures_iter(&data.description).collect();
    let mut line_index = 0;

    for caps in tag_regex.captures_iter(&data.description) {
        let t = &caps[1];
        let v = caps[2].replace('%', "");
        let mut n: Option<String> = None;
        if line_index < lines.len() {
            let cleaned = tag_strip_regex
                .replace_all(&lines[line_index][1], "")
                .trim()
                .to_string();
            if !cleaned.is_empty() {
                n = Some(cleaned);
            }
            line_index += 1;
        }
        if u.contains(&t) {
            if let Some(n_val) = &n {
                let j = percent_prefix_regex.replace(n_val, "").trim().to_string();
                if !j.is_empty() {
                    let is_percent = caps[2].contains('%');
                    let value: Value =
                        if k.iter().any(|&keyword| n_val.contains(keyword)) && is_percent {
                            Value::String(format!("{}%", v))
                        } else {
                            match v.parse::<f64>() {
                                Ok(num) => Value::from(num),
                                Err(_) => continue,
                            }
                        };
                    result.insert(j, value);
                }
            }
        }
    }
    result
}
