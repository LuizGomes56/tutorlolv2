use serde::Serialize;
use tutorlolv2_gen::AbilityLike;

use super::*;
use std::{collections::HashMap, path::Path};

/// Automatically updates every champion in the game. New champions, or big updates to existing
/// champions will need to be rewritten over time. If an error occurs while trying to update a
/// champion, it will be skipped. Writes the resulting json to internal/{champion_name}.json
pub fn run_generator_file(path_name: &str) -> Result<(), Box<dyn std::error::Error>> {
    let result = path_name.read_json::<CdnChampion>()?;
    let name = path_name.json_file_name();
    let name_lower = name.to_lowercase();
    let champion = try_run_generator(&name_lower, result);
    if let Some(champion_data) = champion {
        let string_value = serde_json::to_string_pretty(&champion_data).map_err(|e| {
            println!("Error: {e:#?}");
            e
        })?;
        format!("internal/champions/{}.json", name).write_to_file(string_value.as_bytes())?;
    } else {
        println!("Champion '{}' not found in transformation map", name);
    }
    Ok(())
}

/// Total = Replace all generator files
/// Partial = Replace non #[stable] and #[preserve] only
/// New = Only creates files for champions that were not listed
#[derive(Copy, Clone)]
pub enum GeneratorMode {
    Total,
    Partial,
    New,
}

/// Files will be generated automatically, but checked manually until it is
/// confirmed that the desired format was succesfully achieved.
/// Once it is done, a comment must be added to the header to
/// prevent the generator from editing that file with `#![stable]`, `#![preserve]`.
#[tutorlolv2_macros::trace_time]
pub async fn create_generator_files(mode: GeneratorMode) -> Result<(), Box<dyn std::error::Error>> {
    let champion_names = "internal/champion_names.json".read_json::<HashMap<String, String>>()?;
    let generator_target = "src/generators";

    let mut futures = Vec::new();
    let bind_function = |ability_name: &str, coords: Vec<String>| {
        "ability!($1,$2);"
            .replace("$1", ability_name)
            .replace("$2", &coords.join(","))
    };

    for (_, champion_id) in champion_names {
        match mode {
            GeneratorMode::New => {
                if Path::new(&format!("src/generators/{}.rs", champion_id)).exists() {
                    continue;
                }
            }
            _ => {}
        };

        futures.push(tokio::spawn(async move {
            let path_name = format!("{}/{}.rs", generator_target, champion_id.to_lowercase());
            if let Ok(data) = std::fs::read_to_string(&path_name) {
                match mode {
                    GeneratorMode::Partial => {
                        if data.contains("#![stable]") || data.contains("#![preserve]") {
                            return;
                        }
                    }
                    _ => {}
                }
            }

            let mut autogenerated_content = format!(
                r#"use super::*;

// #![auto_generated]

#[tutorlolv2_macros::generator]
pub fn gen_{}(data: CdnChampion) -> Champion {{
"#,
                champion_id.to_lowercase(),
            );

            let champion_data = match format!("cache/cdn/champions/{}.json", champion_id)
                .read_json::<CdnChampion>()
            {
                Ok(data) => data,
                Err(e) => {
                    eprintln!("Error reading champion file for {}: {:#?}", champion_id, e);
                    return;
                }
            };

            for (key, val) in champion_data.abilities.into_iterator() {
                let coords = transform_ability(&key.to_uppercase(), val);
                if coords.len() > 0 {
                    autogenerated_content.push_str(&bind_function(&key, coords));
                }
            }

            autogenerated_content.push_str("}");
            let _ = path_name.write_to_file(autogenerated_content.trim().as_bytes());
        }));
    }

    for future in futures {
        if let Err(e) = future.await {
            eprintln!("Task join error: {}", e);
        }
    }

    Ok(())
}

/// Takes the reference of the description of one ability, the reference vector
/// where data will be written at, and adds the tuples of scalling found.
fn assign_scalings(description: &String, ref_vec: &mut Vec<String>) {
    if description.is_empty() {
        return;
    }
    let scalings: String = extract_scaled_values(&description);
    if scalings.len() > 0 {
        ref_vec.iter_mut().for_each(|dmg: &mut String| {
            *dmg = format!("{} + {}", dmg, scalings);
        });
    }
}

/// Easier way to get passive damage when the standard format (struct CdnChampion) matches.
///
/// `data` > the reference to the data passed to the caller function.
///
/// `indexes` > the (ability_index, effect_index) of the description string to be extracted.
///
/// `postfix` > optional hardcoded string to be added after each matching in final Vec<String>
///
/// `scalings` > optional index where the description string can be found to get passive's scallings
///
/// `target_vec` > determines if final ocurrence will be written in Minimum or Maximum vector
///
/// `keyname` > name of the key to be added in the map after final Vec<String> is created
///
/// `map` > reference to the map created internally by the caller function. (Must be created)
pub fn extract_passive_damage(
    data: &CdnChampion,
    indexes: (usize, usize),
    postfix: Option<&str>,
    scalings: Option<usize>,
    keyname: AbilityLike,
    map: &mut HashMap<AbilityLike, Ability>,
) {
    let (passive, passive_bounds) = extract_passive_bounds(&data, indexes);

    let mut description = &String::new();

    if let Some(scalings) = scalings {
        description = &passive.effects[scalings].description;
    }

    let mut damage = process_linear_range(passive_bounds, 18, postfix);
    assign_scalings(&description, &mut damage);

    map.insert(keyname, passive.format(damage));
}

/// Helper function to remove the decimal point if it's not needed, or expand floats.
fn trim_f64(val: f64) -> String {
    if val.fract() == 0.0 {
        format!("{:.0}", val)
    } else {
        format!("{}", val)
    }
}

/// Takes the default format of the API and assigns to target_vec the correct format
/// Used internally.
fn extract_ability(modifiers: &[Modifiers]) -> Vec<String> {
    let mut result = Vec::new();
    if modifiers.is_empty() {
        return result;
    }
    let length: usize = modifiers[0].values.len();
    for i in 0..length {
        let mut parts: Vec<String> = Vec::new();
        for modifier in modifiers {
            if let Some(value) = modifier.values.get(i) {
                let raw_unit: &str = modifier.units[i].trim();
                let scallings: String = extract_scaled_values(&raw_unit);
                let unit: String = remove_parenthesized_additions(&raw_unit);
                let cleaned_string: String = if unit.contains('%') {
                    let parts: Vec<&str> = unit.split('%').collect();
                    let suffix: String = parts
                        .get(1)
                        .map_or("".to_string(), |s: &&str| s.trim().to_string());
                    let coef: f64 = value / 100.0;
                    if coef == 1.0 && !suffix.is_empty() {
                        suffix
                    } else if !suffix.is_empty() {
                        format!("({} * {})", trim_f64(coef), suffix)
                    } else {
                        format!("{}", trim_f64(coef))
                    }
                } else if unit.is_empty() {
                    trim_f64(*value)
                } else {
                    format!("{}{}", trim_f64(*value), unit)
                };
                let formatted_string: String = replace_keys(&cleaned_string);
                let final_string: String = if scallings.is_empty() {
                    formatted_string
                } else {
                    format!("{} + {}", formatted_string, scallings)
                };
                parts.push(final_string);
            }
        }
        result.push(parts.join(" + "));
    }
    result
}

/// Lots of passive strings match with a pattern of (number) : (number) ... (+ Scalings)
/// This function returns the first two values it found, assuming there will always be two.
fn extract_passive_bounds(
    data: &CdnChampion,
    indexes: (usize, usize),
) -> (&CdnAbility, (f64, f64)) {
    let (ability_index, effect_index) = indexes;

    let passive: &CdnAbility = data
        .abilities
        .p
        .get(ability_index)
        .expect("ability_index is invalid.");

    let passive_effects: String = passive
        .effects
        .get(effect_index)
        .expect("effect_index is invalid.")
        .description
        .clone();

    let passive_bounds: (f64, f64) = extract_range_values(&passive_effects)
        .expect("Couldn't extract numeric values for passive.");

    (passive, passive_bounds)
}

/// Useful for passives where scalling is linear over all 18 levels.
/// Returns the array with the values for each level adjusted
fn process_linear_range(bounds: (f64, f64), size: usize, postfix: Option<&str>) -> Vec<String> {
    let mut result: Vec<String> = Vec::<String>::new();
    let (start, end) = bounds;
    for i in 0..size {
        let value: f64 = start + (((end - start) * (i as f64)) / (size as f64 - 1.0));
        if let Some(postfix) = postfix {
            result.push(format!("({} + {})", value, postfix));
            continue;
        }
        result.push(format!("{}", value));
    }
    result
}

/// Takes a pattern of `[Index on Vec<Effect>], [Index on Vec<Leveling>], [(Keyname, Max/Min)]`
/// And assigns to the map the correct format that will be used internally.
pub fn extract_ability_damage(
    data: &CdnAbility,
    map: &mut HashMap<AbilityLike, Ability>,
    pattern: &[(usize, usize, AbilityLike)],
) {
    let mut indexes = HashMap::new();

    for (effect_index, leveling_index, keyname) in pattern.into_iter() {
        indexes
            .entry(*effect_index)
            .or_insert(HashMap::new())
            .insert(*leveling_index, keyname);
    }

    for (effect_index, leveling) in indexes.into_iter() {
        for (leveling_index, keyname) in leveling.into_iter() {
            if let Some(effects) = data.effects.get(effect_index) {
                if let Some(level_entry) = effects.leveling.get(leveling_index) {
                    let modifiers = &level_entry.modifiers;
                    map.insert(*keyname, data.format(extract_ability(&modifiers)));
                }
            } else {
                println!(
                    "Invalid index: effect: '{}' or leveling: '{}'",
                    effect_index, leveling_index
                );
                continue;
            }
        }
    }
}

/// Returns a new array with the coordinates where an ability was found according to CDN API
fn transform_ability(key: &str, abilities: &[CdnAbility]) -> Vec<String> {
    let mut generator_keybinds = Vec::<String>::new();

    for (ability_index, ability) in abilities.iter().enumerate() {
        for (effect_index, effect) in ability.effects.iter().enumerate() {
            for (leveling_index, leveling) in effect.leveling.iter().enumerate() {
                let attr = leveling
                    .attribute
                    .as_deref()
                    .unwrap_or_default()
                    .to_lowercase();

                if !attr.contains("damage") {
                    continue;
                }

                let suffix = if attr.contains("monster") {
                    "_MNSTR"
                } else if attr.contains("bonus") {
                    "_BONUS"
                } else if attr.contains("maximum")
                    || attr.contains("total")
                    || attr.contains("increased")
                {
                    "_MAX"
                } else if attr.contains("minimum") {
                    "_MIN"
                } else {
                    ""
                };

                let base_key = format!(
                    "{}_{}_{}_{}",
                    key, ability_index, effect_index, leveling_index
                );
                let final_key = format!("{}{}", base_key, suffix);

                generator_keybinds.push(format!(
                    "({}, {}, \"{}\")",
                    effect_index, leveling_index, final_key,
                ));
            }
        }
    }
    generator_keybinds
}

pub trait OrderJson<T: Serialize> {
    fn into_iter_ord(self) -> impl Iterator<Item = (String, T)>;
}

impl OrderJson<CdnChampion> for HashMap<String, CdnChampion> {
    fn into_iter_ord(self) -> impl Iterator<Item = (String, CdnChampion)> {
        let mut vec_self = self.into_iter().collect::<Vec<_>>();
        for (_, champion) in vec_self.iter_mut() {
            for ability_list in [
                &mut champion.abilities.q,
                &mut champion.abilities.w,
                &mut champion.abilities.e,
                &mut champion.abilities.r,
                &mut champion.abilities.p,
            ] {
                for ability in ability_list {
                    ability
                        .effects
                        .sort_by(|a, b| a.description.cmp(&b.description));
                    for effect in &mut ability.effects {
                        effect.leveling.sort_by(|a, b| {
                            a.attribute
                                .as_deref()
                                .unwrap_or("")
                                .cmp(b.attribute.as_deref().unwrap_or(""))
                        });
                    }
                }
            }
        }
        vec_self.into_iter()
    }
}

impl OrderJson<CdnItem> for HashMap<String, CdnItem> {
    fn into_iter_ord(self) -> impl Iterator<Item = (String, CdnItem)> {
        let mut vec_self = self.into_iter().collect::<Vec<_>>();
        for (_, item) in vec_self.iter_mut() {
            item.active.sort_by(|a, b| a.effects.cmp(&b.effects));
            item.passives.sort_by(|a, b| a.effects.cmp(&b.effects));
        }
        vec_self.into_iter()
    }
}
